## [PR 22821](https://github.com/scipy/scipy/pull/22821)

## PR Summary

This PR adds array API standard support to the scipy signal processing functions lp2{lp,hp,bp,bs} and their zpk variants, enhancing compatibility with array backends like JAX and CuPy. The changes are primarily mechanical, following issue #20678, with necessary updates to tests for continued functionality. The PR has been merged into the main branch and is included in the upcoming 1.16.0 milestone.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# scipy/signal/_filter_design.py
--------------------------------------------------------------------------------
class BadCoefficients(UserWarning):
...
def _is_int_type(x):
...
def findfreqs(num, den, N, kind='ba'):
...
def freqs(b, a, worN=200, plot=None):
...
def freqs_zpk(z, p, k, worN=200):
...
def freqz(b, a=1, worN=512, whole=False, plot=None, fs=2*pi,
          include_nyquist=False):
...
def freqz_zpk(z, p, k, worN=512, whole=False, fs=2*pi):
...
def group_delay(system, w=512, whole=False, fs=2*pi):
...
def _validate_sos(sos):
...
def freqz_sos(sos, worN=512, whole=False, fs=2*pi):
...
def sosfreqz(*args, **kwargs):
...
def _cplxreal(z, tol=None):
...
def _cplxpair(z, tol=None):
...
def tf2zpk(b, a):
...
def zpk2tf(z, p, k):
...
def tf2sos(b, a, pairing=None, *, analog=False):
...
def sos2tf(sos):
...
def sos2zpk(sos):
...
def _nearest_real_complex_idx(fro, to, which):
...
def _single_zpksos(z, p, k):
...
def zpk2sos(z, p, k, pairing=None, *, analog=False):
...
        def idx_worst(p):
...
        def idx_worst(p):
...
def _align_nums(nums, xp):
...

def _trim_zeros(filt, trim='fb'):
    # https://github.com/numpy/numpy/blob/v2.1.0/numpy/lib/_function_base_impl.py#L1874-L1925
    first = 0
    trim = trim.upper()
    if 'F' in trim:
        for i in filt:
            if i != 0.:
                break
            else:
                first = first + 1 #❗UNCOVERED: NEED TEST
    last = filt.shape[0]
    if 'B' in trim:
        for i in filt[::-1]: #❗UNCOVERED: NEED TEST
            if i != 0.: #❗UNCOVERED: NEED TEST
                break #❗UNCOVERED: NEED TEST
            else:
                last = last - 1 #❗UNCOVERED: NEED TEST
    return filt[first:last]


def normalize(b, a):
    """Normalize numerator/denominator of a continuous-time transfer function.

    If values of `b` are too close to 0, they are removed. In that case, a
    BadCoefficients warning is emitted.

    Parameters
...
def lp2lp(b, a, wo=1.0):
...


def _resize(a, new_shape, xp):
    # https://github.com/numpy/numpy/blob/v2.2.4/numpy/_core/fromnumeric.py#L1535
    a = xp.reshape(a, (-1,))

    new_size = 1
    for dim_length in new_shape:
        new_size *= dim_length
        if dim_length < 0:
            raise ValueError( #❗UNCOVERED: NEED TEST
                'all elements of `new_shape` must be non-negative' #❗UNCOVERED: NEED TEST
            ) #❗UNCOVERED: NEED TEST

    if xp_size(a) == 0 or new_size == 0:
        # First case must zero fill. The second would have repeats == 0.
        return xp.zeros_like(a, shape=new_shape) #❗UNCOVERED: NEED TEST

    repeats = -(-new_size // xp_size(a))  # ceil division
    a = xp.concat((a,) * repeats)[:new_size]

    return xp.reshape(a, new_shape)


def lp2hp(b, a, wo=1.0):
    r"""
    Transform a lowpass filter prototype to a highpass filter.
...

    try:
        wo = float(wo)
    except TypeError:
        wo = float(wo[0])
    d = a.shape[0]
    n = b.shape[0]
    if wo != 1:
        pwo = wo ** xp.arange(max((d, n)), dtype=b.dtype)
    else:
        pwo = xp.ones(max((d, n)), dtype=b.dtype) #❗UNCOVERED: NEED TEST
    if d >= n:
        outa = xp.flip(a) * pwo
        outb = _resize(b, (d,), xp=xp)
        outb[n:] = 0.0
        outb[:n] = xp.flip(b) * pwo[:n]
    else:
        outb = xp.flip(b) * pwo #❗UNCOVERED: NEED TEST
        outa = _resize(a, (n,), xp=xp) #❗UNCOVERED: NEED TEST
        outa[d:] = 0.0
        outa[:d] = xp.flip(a) * pwo[:d] #❗UNCOVERED: NEED TEST

    return normalize(outb, outa)


def lp2bp(b, a, wo=1.0, bw=1.0):
    r"""
    Transform a lowpass filter prototype to a bandpass filter.

    Return an analog band-pass filter with center frequency `wo` and
    bandwidth `bw` from an analog low-pass filter prototype with unity
...
def lp2bs(b, a, wo=1.0, bw=1.0):
...
def bilinear(b, a, fs=1.0):
...
def _validate_gpass_gstop(gpass, gstop):

...
def iirdesign(wp, ws, gpass, gstop, analog=False, ftype='ellip', output='ba',
              fs=None):
...
def iirfilter(N, Wn, rp=None, rs=None, btype='band', analog=False,
              ftype='butter', output='ba', fs=None):
...
def _relative_degree(z, p):
...
def bilinear_zpk(z, p, k, fs):
...
def lp2lp_zpk(z, p, k, wo=1.0):
...
def lp2hp_zpk(z, p, k, wo=1.0):
...
def lp2bp_zpk(z, p, k, wo=1.0, bw=1.0):
...
def lp2bs_zpk(z, p, k, wo=1.0, bw=1.0):
...
def butter(N, Wn, btype='low', analog=False, output='ba', fs=None):
...
def cheby1(N, rp, Wn, btype='low', analog=False, output='ba', fs=None):
...
def cheby2(N, rs, Wn, btype='low', analog=False, output='ba', fs=None):
...
def ellip(N, rp, rs, Wn, btype='low', analog=False, output='ba', fs=None):
...
def bessel(N, Wn, btype='low', analog=False, output='ba', norm='phase',
           fs=None):
...
def maxflat():
...
def yulewalk():
...
def band_stop_obj(wp, ind, passb, stopb, gpass, gstop, type):
...
def _pre_warp(wp, ws, analog):
    # Pre-warp frequencies for digital filter design
...
def _validate_wp_ws(wp, ws, fs, analog):
...
def _find_nat_freq(stopb, passb, gpass, gstop, filter_type, filter_kind):
...
def _postprocess_wn(WN, analog, fs):
...
def buttord(wp, ws, gpass, gstop, analog=False, fs=None):
...
def cheb1ord(wp, ws, gpass, gstop, analog=False, fs=None):
...
def cheb2ord(wp, ws, gpass, gstop, analog=False, fs=None):
...
def _pow10m1(x):
...
def ellipord(wp, ws, gpass, gstop, analog=False, fs=None):
...
def buttap(N):
...
def cheb1ap(N, rp):
...
def cheb2ap(N, rs):
...
def _ellipdeg(n, m1):
...
def _arc_jac_sn(w, m):
...
    def _complement(kx):
        # (1-k**2) ** 0.5; the expression below
        # works for small kx
...
def _arc_jac_sc1(w, m):
...
def ellipap(N, rp, rs):
...
def _falling_factorial(x, n):
...
def _bessel_poly(n, reverse=False):
...
def _campos_zeros(n):
...
def _aberth(f, fp, x0, tol=1e-15, maxiter=50):
...
def _bessel_zeros(N):
...
    def f(x):
...
    def fp(x):
...
def _norm_factor(p, k):
...
    def G(w):
...
    def cutoff(w):
...
def besselap(N, norm='phase'):
...
def iirnotch(w0, Q, fs=2.0):
...
def iirpeak(w0, Q, fs=2.0):
...
def _design_notch_peak_filter(w0, Q, ftype, fs=2.0):
...
def iircomb(w0, Q, ftype='notch', fs=2.0, *, pass_zero=False):
...
def _hz_to_erb(hz):
...
def gammatone(freq, ftype, order=None, numtaps=None, fs=None):

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# scipy/signal/tests/test_filter_design.py
--------------------------------------------------------------------------------
def mpmath_check(min_ver):
...
class TestCplxPair:

    def test_trivial_input(self):
...
    def test_output_order(self):
...
    def test_real_integer_input(self):
...
    def test_tolerances(self):
...
    def test_unmatched_conjugates(self):
        # 1+2j is unmatched
...
class TestCplxReal:

    def test_trivial_input(self):
...
    def test_output_order(self):
...
    def test_unmatched_conjugates(self):
        # 1+2j is unmatched
...
    def test_real_integer_input(self):
...
class TestTf2zpk:

    @pytest.mark.parametrize('dt', (np.float64, np.complex128))
    def test_simple(self, dt):
...
    def test_bad_filter(self):
        # Regression test for #651: better handling of badly conditioned
        # filter coefficients.
...
class TestZpk2Tf:

    def test_identity(self):
...
    def test_conj_pair(self):
        # conjugate pairs give real-coeff num & den
...
    def test_complexk(self):
        # regression: z, p real, k complex k gave real b, a
...
class TestSos2Zpk:

    def test_basic(self):
...
    def test_fewer_zeros(self):
...
class TestSos2Tf:

    def test_basic(self):
...
class TestTf2Sos:

    def test_basic(self):
...
    def test_analog(self, b, a, analog, sos):
...
class TestZpk2Sos:

    @pytest.mark.parametrize('dt', 'fdgFDG')
    @pytest.mark.parametrize('pairing, analog',
                             [('nearest', False),
                              ('keep_odd', False),
                              ('minimal', False),
                              ('minimal', True)])
    def test_dtypes(self, dt, pairing, analog):
...
    def test_basic(self):
...
    def test_pairing(self, pairing, sos):
...
    def test_analog(self, p, sos_dt):
        # test `analog` argument
        # for discrete time, poles closest to unit circle should appear last
        # for cont. time, poles closest to imaginary axis should appear last
...
    def test_bad_args(self):
...
class TestFreqs:

    def test_basic(self):
...
    def test_output(self):
        # 1st order low-pass filter: H(s) = 1 / (s + 1)
...
    def test_freq_range(self):
        # Test that freqresp() finds a reasonable frequency range.
        # 1st order low-pass filter: H(s) = 1 / (s + 1)
        # Expected range is from 0.01 to 10.
...
    def test_plot(self):

        def plot(w, h):
...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_w_or_N_types(self):
        # Measure at 8 equally-spaced points
...
class TestFreqs_zpk:

    def test_basic(self):
...
    def test_output(self):
        # 1st order low-pass filter: H(s) = 1 / (s + 1)
...
    def test_freq_range(self):
        # Test that freqresp() finds a reasonable frequency range.
        # 1st order low-pass filter: H(s) = 1 / (s + 1)
        # Expected range is from 0.01 to 10.
...
    def test_vs_freqs(self):
...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_w_or_N_types(self):
        # Measure at 8 equally-spaced points
...
class TestFreqz:

    def test_ticket1441(self):
...
    def test_basic(self):
...
    def test_basic_whole(self):
...
    def test_plot(self):

        def plot(w, h):
...
    def test_fft_wrapping(self):
        # Some simple real FIR filters
...
    def test_broadcasting1(self):
        # Test broadcasting with worN an integer or a 1-D array,
        # b and a are n-dimensional arrays.
...
    def test_broadcasting2(self):
        # Test broadcasting with worN an integer or a 1-D array,
        # b is an n-dimensional array, and a is left at the default value.
...
    def test_broadcasting3(self):
        # Test broadcasting where b.shape[-1] is the same length
        # as worN, and a is left at the default value.
...
    def test_broadcasting4(self):
        # Test broadcasting with worN a 2-D array.
...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_fs_param(self):
...
    def test_w_or_N_types(self):
        # Measure at 7 (polyval) or 8 (fft) equally-spaced points
...
    def test_nyquist(self):
...
    def test_17289(self, whole, nyquist, worN):
...
    def test_fs_validation(self):
...
class Testfreqz_sos:

    def test_freqz_sos_basic(self):
        # Compare the results of freqz and freqz_sos for a low order
        # Butterworth filter.

...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_freqz_sos_design(self):
        # Compare freqz_sos output against expected values for different
        # filter types

        # from cheb2ord
...
    def test_freqz_sos_design_ellip(self):
...
    def test_freqz_sos_against_mp(self):
        # Compare the result of freqz_sos applied to a high order Butterworth
        # filter against the result computed using mpmath.  (signal.freqz fails
        # miserably with such high order filters.)
...
    def test_fs_param(self):
...
    def test_w_or_N_types(self):
        # Measure at 7 (polyval) or 8 (fft) equally-spaced points
...
    def test_fs_validation(self):
...
class TestFreqz_zpk:

    def test_ticket1441(self):
...
    def test_basic(self):
...
    def test_basic_whole(self):
...
    def test_vs_freqz(self):
...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_fs_param(self):
...
    def test_w_or_N_types(self):
        # Measure at 8 equally-spaced points
...
    def test_fs_validation(self):
...
class TestNormalize:

    def test_allclose(self):
...
    def test_errors(self):
...
class TestLp2lp:

    def test_basic(self, xp):
...
class TestLp2hp:

    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
    def test_basic(self, xp):
...
class TestLp2bp:

    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
    def test_basic(self, xp):
...
class TestLp2bs:

    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
    def test_basic(self, xp):
...
class TestBilinear:
...
    def test_exceptions(self):
...
    def test_basic(self):
        # reference output values computed with sympy
...
    def test_ignore_leading_zeros(self):
        # regression for gh-6606
        # results shouldn't change when leading zeros are added to
        # input numerator or denominator
...
    def test_complex(self):
        # reference output values computed with sympy
        # this is an elliptical filter, 5Hz width, centered at +50Hz:
        #     z, p, k = signal.ellip(2, 0.5, 20, 2*np.pi*5/2, output='zpk', analog=True)
        #     z = z.astype(complex) + 2j * np.pi * 50
        #     p = p.astype(complex) + 2j * np.pi * 50
        #     b, a = signal.zpk2tf(z, p, k)
...
    def test_fs_validation(self):
...
            bilinear(b, a, fs=None)


def _sort_cmplx(arr, xp):
    # xp.sort is undefined for complex dtypes. Here we only need some
    # consistent way to sort a complex array, including equal magnitude elements.
    arr = xp.asarray(arr)
    if xp.isdtype(arr.dtype, 'complex floating'):
        sorter = abs(arr) + xp.real(arr) + xp.imag(arr)**3
    else:
        sorter = arr #❗UNCOVERED: NEED TEST

    idxs = xp.argsort(sorter)
    return arr[idxs]


class TestLp2lp_zpk:

    @xfail_xp_backends(
        'dask.array', reason='https://github.com/dask/dask/issues/11883'
    )
    def test_basic(self, xp):
...
    def test_fs_validation(self):
...
class TestLp2hp_zpk:

    @xfail_xp_backends(
        'dask.array', reason='https://github.com/dask/dask/issues/11883'
    )
    def test_basic(self, xp):
...
class TestLp2bp_zpk:

    @xfail_xp_backends(
        'dask.array', reason='https://github.com/dask/dask/issues/11883'
    )
    def test_basic(self, xp):
...
class TestLp2bs_zpk:

    @xfail_xp_backends(
        'dask.array', reason='https://github.com/dask/dask/issues/11883'
    )
    def test_basic(self, xp):
...
class TestBilinear_zpk:

    @xfail_xp_backends(
        'dask.array', reason='https://github.com/dask/dask/issues/11883'
    )
    def test_basic(self, xp):
...
class TestPrototypeType:

    def test_output_type(self):
        # Prototypes should consistently output arrays, not lists
        # https://github.com/scipy/scipy/pull/441
...
def dB(x):
    # Return magnitude in decibels, avoiding divide-by-zero warnings
    # (and deal with some "not less-ordered" errors when -inf shows up)
...
class TestButtord:

    def test_lowpass(self):
...
    def test_highpass(self):
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_analog(self):
...
    def test_fs_param(self):
...
    def test_invalid_input(self):
...
    def test_runtime_warnings(self):
...
    def test_ellip_butter(self):
        # The purpose of the test is to compare to some known output from past
        # scipy versions. The values to compare to are generated with scipy
        # 1.9.1 (there is nothing special about this particular version though)
...
    def test_fs_validation(self):
...
class TestCheb1ord:

    def test_lowpass(self):
...
    def test_highpass(self):
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_analog(self):
...
    def test_fs_param(self):
...
    def test_invalid_input(self):
...
    def test_ellip_cheb1(self):
        # The purpose of the test is to compare to some known output from past
        # scipy versions. The values to compare to are generated with scipy
        # 1.9.1 (there is nothing special about this particular version though)
...
    def test_fs_validation(self):
...
class TestCheb2ord:

    def test_lowpass(self):
...
    def test_highpass(self):
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_analog(self):
...
    def test_fs_param(self):
...
    def test_invalid_input(self):
...
    def test_ellip_cheb2(self):
        # The purpose of the test is to compare to some known output from past
        # scipy versions. The values to compare to are generated with scipy
        # 1.9.1 (there is nothing special about this particular version though)
...
    def test_fs_validation(self):
...
class TestEllipord:

    def test_lowpass(self):
...
    def test_lowpass_1000dB(self):
        # failed when ellipkm1 wasn't used in ellipord and ellipap
...
    def test_highpass(self):
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_analog(self):
...
    def test_fs_param(self):
...
    def test_invalid_input(self):
...
    def test_ellip_butter(self):
        # The purpose of the test is to compare to some known output from past
        # scipy versions. The values to compare to are generated with scipy
        # 1.9.1 (there is nothing special about this particular version though)
...
    def test_fs_validation(self):
...
class TestBessel:

    def test_degenerate(self):
...
    def test_high_order(self):
        # high even order, 'phase'
...
    def test_refs(self):
        # Compare to http://www.crbond.com/papers/bsf2.pdf
        # "Delay Normalized Bessel Polynomial Coefficients"
...
    def test_hardcoded(self):
        # Compare to values from original hardcoded implementation
...
    def test_norm_phase(self):
        # Test some orders and frequencies and see that they have the right
        # phase at w0
...
    def test_norm_mag(self):
        # Test some orders and frequencies and see that they have the right
        # mag at w0
...
    def test_norm_delay(self):
        # Test some orders and frequencies and see that they have the right
        # delay at DC
...
    def test_norm_factor(self):
...
    def test_bessel_poly(self):
...
    def test_bessel_zeros(self):
...
    def test_invalid(self):
...
    def test_fs_param(self):
...
class TestButter:

    def test_degenerate(self):
        # 0-order filter is just a passthrough
...
    def test_basic(self):
        # analog s-plane
...
    def test_highpass(self):
        # highpass, high even order
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_ba_output(self):
...
    def test_fs_param(self):
...
class TestCheby1:

    def test_degenerate(self):
        # 0-order filter is just a passthrough
        # Even-order filters have DC gain of -rp dB
...
    def test_basic(self):
...
    def test_highpass(self):
        # high even order
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_ba_output(self):
        # with transfer function conversion,  without digital conversion
...
    def test_fs_param(self):
...
class TestCheby2:

    def test_degenerate(self):
        # 0-order filter is just a passthrough
        # Stopband ripple factor doesn't matter
...
    def test_basic(self):
...
    def test_highpass(self):
        # high even order
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_ba_output(self):
        # with transfer function conversion, without digital conversion
...
    def test_fs_param(self):
...
class TestEllip:

    def test_degenerate(self):
        # 0-order filter is just a passthrough
        # Even-order filters have DC gain of -rp dB
        # Stopband ripple factor doesn't matter
...
    def test_basic(self):
...
    def test_highpass(self):
        # high even order
...
    def test_bandpass(self):
...
    def test_bandstop(self):
...
    def test_ba_output(self):
        # with transfer function conversion,  without digital conversion
...
    def test_fs_param(self):
...
    def test_fs_validation(self):
...
def test_sos_consistency():
    # Consistency checks of output='sos' for the specialized IIR filter
    # design functions.
...
class TestIIRNotch:

    def test_ba_output(self):
        # Compare coefficients with Matlab ones
        # for the equivalent input:
...
    def test_frequency_response(self):
        # Get filter coefficients
...
    def test_errors(self):
        # Exception should be raised if w0 > 1 or w0 <0
...
    def test_fs_param(self):
        # Get filter coefficients
...
class TestIIRPeak:

    def test_ba_output(self):
        # Compare coefficients with Matlab ones
        # for the equivalent input:
...
    def test_frequency_response(self):
        # Get filter coefficients
...
    def test_errors(self):
        # Exception should be raised if w0 > 1 or w0 <0
...
    def test_fs_param(self):
        # Get filter coefficients
...
class TestIIRComb:
    # Test erroneous input cases
    def test_invalid_input(self):
        # w0 is <= 0 or >= fs / 2
...
    def test_frequency_response(self, ftype):
        # Create a notching or peaking comb filter at 1000 Hz
...
    def test_pass_zero(self, ftype, pass_zero, peak, notch):
        # Create a notching or peaking comb filter
...
    def test_iir_symmetry(self):
...
    def test_ba_output(self):
...
    def test_nearest_divisor(self):
        # Create a notching comb filter
...
    def test_fs_validation(self):
...
class TestIIRDesign:

    def test_exceptions(self):
...
    def test_fs_validation(self):
...
class TestIIRFilter:

    def test_symmetry(self):
        # All built-in IIR filters are real, so should have perfectly
        # symmetrical poles and zeros. Then ba representation (using
        # numpy.poly) will be purely real instead of having negligible
        # imaginary parts.
...
    def test_int_inputs(self):
        # Using integer frequency arguments and large N should not produce
        # numpy integers that wraparound to negative numbers
...
    def test_invalid_wn_size(self):
        # low and high have 1 Wn, band and stop have 2 Wn
...
    def test_invalid_wn_range(self):
        # For digital filters, 0 <= Wn <= 1
...
    def test_analog_sos(self):
        # first order Butterworth filter with Wn = 1 has tf 1/(s+1)
...
    def test_wn1_ge_wn0(self):
        # gh-15773: should raise error if Wn[0] >= Wn[1]
...
class TestGroupDelay:
    def test_identity_filter(self):
...
    def test_fir(self):
        # Let's design linear phase FIR and check that the group delay
        # is constant.
...
    def test_iir(self):
        # Let's design Butterworth filter and test the group delay at
        # some points against MATLAB answer.
...
    def test_singular(self):
        # Let's create a filter with zeros and poles on the unit circle and
        # check if warnings are raised at those frequencies.
...
    def test_backward_compat(self):
        # For backward compatibility, test if None act as a wrapper for default
...
    def test_fs_param(self):
        # Let's design Butterworth filter and test the group delay at
        # some points against the normalized frequency answer.
...
    def test_w_or_N_types(self):
        # Measure at 8 equally-spaced points
...
    def test_complex_coef(self):
        # gh-19586: handle complex coef TFs
        #
        # for g(z) = (alpha*z+1)/(1+conjugate(alpha)), group delay is
        # given by function below.
        #
        # def gd_expr(w, alpha):
        #     num = 1j*(abs(alpha)**2-1)*np.exp(1j*w)
        #     den = (alpha*np.exp(1j*w)+1)*(np.exp(1j*w)+np.conj(alpha))
        #     return -np.imag(num/den)

        # arbitrary non-real alpha
...
    def test_fs_validation(self):
...
class TestGammatone:
    # Test erroneous input cases.
    def test_invalid_input(self):
        # Cutoff frequency is <= 0 or >= fs / 2.
...
    def test_frequency_response(self):
...
    def test_iir_symmetry(self):
...
    def test_fir_ba_output(self):
...
    def test_iir_ba_output(self):
...
    def test_fs_validation(self):

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# scipy/signal/tests/test_signaltools.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/scipy/signal/_filter_design.py b/scipy/signal/_filter_design.py
index d72af0b11e03..d51f9eae183d 100644
--- a/scipy/signal/_filter_design.py
+++ b/scipy/signal/_filter_design.py
@@ -4,11 +4,10 @@
 import warnings
 
 import numpy as np
-from numpy import (atleast_1d, poly, polyval, roots, real, asarray,
-                   resize, pi, absolute, sqrt, tan, log10,
+from numpy import (atleast_1d, poly, polyval, roots, asarray,
+                   pi, absolute, sqrt, tan, log10,
                    arcsinh, sin, exp, cosh, arccosh, ceil, conjugate,
-                   zeros, sinh, append, concatenate, prod, ones, full, array,
-                   mintypecode)
+                   sinh, concatenate, prod, array)
 from numpy.polynomial.polynomial import polyval as npp_polyval
 from numpy.polynomial.polynomial import polyvalfromroots
 
@@ -17,6 +16,10 @@
 from scipy._lib._util import float_factorial
 from scipy.signal._arraytools import _validate_fs
 
+import scipy._lib.array_api_extra as xpx
+from scipy._lib._array_api import array_namespace, xp_promote, xp_size
+from scipy._lib.array_api_compat import numpy as np_compat
+
 
 __all__ = ['findfreqs', 'freqs', 'freqz', 'tf2zpk', 'zpk2tf', 'normalize',
            'lp2lp', 'lp2hp', 'lp2bp', 'lp2bs', 'bilinear', 'iirdesign',
@@ -1676,7 +1679,7 @@ def idx_worst(p):
     return sos
 
 
-def _align_nums(nums):
+def _align_nums(nums, xp):
     """Aligns the shapes of multiple numerators.
 
     Given an array of numerator coefficient arrays [[a_1, a_2,...,
@@ -1701,19 +1704,19 @@ def _align_nums(nums):
         # The statement can throw a ValueError if one
         # of the numerators is a single digit and another
         # is array-like e.g. if nums = [5, [1, 2, 3]]
-        nums = asarray(nums)
+        nums = xp.asarray(nums)
 
-        if not np.issubdtype(nums.dtype, np.number):
+        if not xp.isdtype(nums.dtype, "numeric"):
             raise ValueError("dtype of numerator is non-numeric")
 
         return nums
 
     except ValueError:
-        nums = [np.atleast_1d(num) for num in nums]
-        max_width = max(num.size for num in nums)
+        nums = [xpx.atleast_nd(xp.asarray(num), ndim=1) for num in nums]
+        max_width = max(xp_size(num) for num in nums)
 
         # pre-allocate
-        aligned_nums = np.zeros((len(nums), max_width))
+        aligned_nums = xp.zeros((len(nums), max_width))
 
         # Create numerators with padded zeros
         for index, num in enumerate(nums):
@@ -1722,6 +1725,26 @@ def _align_nums(nums):
         return aligned_nums
 
 
+def _trim_zeros(filt, trim='fb'):
+    # https://github.com/numpy/numpy/blob/v2.1.0/numpy/lib/_function_base_impl.py#L1874-L1925
+    first = 0
+    trim = trim.upper()
+    if 'F' in trim:
+        for i in filt:
+            if i != 0.:
+                break
+            else:
+                first = first + 1
+    last = filt.shape[0]
+    if 'B' in trim:
+        for i in filt[::-1]:
+            if i != 0.:
+                break
+            else:
+                last = last - 1
+    return filt[first:last]
+
+
 def normalize(b, a):
     """Normalize numerator/denominator of a continuous-time transfer function.
 
@@ -1778,30 +1801,37 @@ def normalize(b, a):
     Badly conditioned filter coefficients (numerator): the results may be meaningless
 
     """
-    num, den = b, a
+    try:
+        xp = array_namespace(b, a)
+    except TypeError:
+        # object arrays, test_ltisys.py::TestSS2TF::test_simo_round_trip
+        xp = np_compat
 
-    den = np.asarray(den)
-    den = np.atleast_1d(den)
-    num = np.atleast_2d(_align_nums(num))
+    den = xp.asarray(a)
+    den = xpx.atleast_nd(den, ndim=1, xp=xp)
+
+    num = xp.asarray(b)
+    num = xpx.atleast_nd(_align_nums(num, xp), ndim=2, xp=xp)
 
     if den.ndim != 1:
         raise ValueError("Denominator polynomial must be rank-1 array.")
     if num.ndim > 2:
         raise ValueError("Numerator polynomial must be rank-1 or"
                          " rank-2 array.")
-    if np.all(den == 0):
+    if xp.all(den == 0):
         raise ValueError("Denominator must have at least on nonzero element.")
 
     # Trim leading zeros in denominator, leave at least one.
-    den = np.trim_zeros(den, 'f')
+    den = _trim_zeros(den, 'f')
 
     # Normalize transfer function
     num, den = num / den[0], den / den[0]
 
     # Count numerator columns that are all zero
     leading_zeros = 0
-    for col in num.T:
-        if np.allclose(col, 0, atol=1e-14):
+    for j in range(num.shape[-1]):
+        col = num[:, j]
+        if xp.all(xp.abs(col) <= 1e-14):
             leading_zeros += 1
         else:
             break
@@ -1879,15 +1909,20 @@ def lp2lp(b, a, wo=1.0):
     >>> plt.legend()
 
     """
-    a, b = map(atleast_1d, (a, b))
+    xp = array_namespace(a, b)
+    a, b = map(xp.asarray, (a, b))
+    a, b = xp_promote(a, b, force_floating=True, xp=xp)
+    a = xpx.atleast_nd(a, ndim=1, xp=xp)
+    b = xpx.atleast_nd(b, ndim=1, xp=xp)
+
     try:
         wo = float(wo)
     except TypeError:
         wo = float(wo[0])
-    d = len(a)
-    n = len(b)
+    d = a.shape[0]
+    n = b.shape[0]
     M = max((d, n))
-    pwo = pow(wo, np.arange(M - 1, -1, -1))
+    pwo = wo ** xp.arange(M - 1, -1, -1, dtype=xp.float64)
     start1 = max((n - d, 0))
     start2 = max((d - n, 0))
     b = b * pwo[start1] / pwo[start2:]
@@ -1895,6 +1930,28 @@ def lp2lp(b, a, wo=1.0):
     return normalize(b, a)
 
 
+def _resize(a, new_shape, xp):
+    # https://github.com/numpy/numpy/blob/v2.2.4/numpy/_core/fromnumeric.py#L1535
+    a = xp.reshape(a, (-1,))
+
+    new_size = 1
+    for dim_length in new_shape:
+        new_size *= dim_length
+        if dim_length < 0:
+            raise ValueError(
+                'all elements of `new_shape` must be non-negative'
+            )
+
+    if xp_size(a) == 0 or new_size == 0:
+        # First case must zero fill. The second would have repeats == 0.
+        return xp.zeros_like(a, shape=new_shape)
+
+    repeats = -(-new_size // xp_size(a))  # ceil division
+    a = xp.concat((a,) * repeats)[:new_size]
+
+    return xp.reshape(a, new_shape)
+
+
 def lp2hp(b, a, wo=1.0):
     r"""
     Transform a lowpass filter prototype to a highpass filter.
@@ -1953,27 +2010,33 @@ def lp2hp(b, a, wo=1.0):
     >>> plt.legend()
 
     """
-    a, b = map(atleast_1d, (a, b))
+    xp = array_namespace(a, b)
+
+    a, b = map(xp.asarray, (a, b))
+    a, b = xp_promote(a, b, force_floating=True, xp=xp)
+    a = xpx.atleast_nd(a, ndim=1, xp=xp)
+    b = xpx.atleast_nd(b, ndim=1, xp=xp)
+
     try:
         wo = float(wo)
     except TypeError:
         wo = float(wo[0])
-    d = len(a)
-    n = len(b)
+    d = a.shape[0]
+    n = b.shape[0]
     if wo != 1:
-        pwo = pow(wo, np.arange(max((d, n))))
+        pwo = wo ** xp.arange(max((d, n)), dtype=b.dtype)
     else:
-        pwo = np.ones(max((d, n)), b.dtype.char)
+        pwo = xp.ones(max((d, n)), dtype=b.dtype)
     if d >= n:
-        outa = a[::-1] * pwo
-        outb = resize(b, (d,))
+        outa = xp.flip(a) * pwo
+        outb = _resize(b, (d,), xp=xp)
         outb[n:] = 0.0
-        outb[:n] = b[::-1] * pwo[:n]
+        outb[:n] = xp.flip(b) * pwo[:n]
     else:
-        outb = b[::-1] * pwo
-        outa = resize(a, (n,))
+        outb = xp.flip(b) * pwo
+        outa = _resize(a, (n,), xp=xp)
         outa[d:] = 0.0
-        outa[:d] = a[::-1] * pwo[:d]
+        outa[:d] = xp.flip(a) * pwo[:d]
 
     return normalize(outb, outa)
 
@@ -2038,16 +2101,20 @@ def lp2bp(b, a, wo=1.0, bw=1.0):
     >>> plt.ylabel('Amplitude [dB]')
     >>> plt.legend()
     """
+    xp = array_namespace(a, b)
 
-    a, b = map(atleast_1d, (a, b))
-    D = len(a) - 1
-    N = len(b) - 1
-    artype = mintypecode((a, b))
+    a, b = map(xp.asarray, (a, b))
+    a, b = xp_promote(a, b, force_floating=True, xp=xp)
+    a = xpx.atleast_nd(a, ndim=1, xp=xp)
+    b = xpx.atleast_nd(b, ndim=1, xp=xp)
+
+    D = a.shape[0] - 1
+    N = b.shape[0] - 1
     ma = max([N, D])
     Np = N + ma
     Dp = D + ma
-    bprime = np.empty(Np + 1, artype)
-    aprime = np.empty(Dp + 1, artype)
+    bprime = xp.empty(Np + 1, dtype=b.dtype)
+    aprime = xp.empty(Dp + 1, dtype=a.dtype)
     wosq = wo * wo
     for j in range(Np + 1):
         val = 0.0
@@ -2126,15 +2193,20 @@ def lp2bs(b, a, wo=1.0, bw=1.0):
     >>> plt.ylabel('Amplitude [dB]')
     >>> plt.legend()
     """
-    a, b = map(atleast_1d, (a, b))
-    D = len(a) - 1
-    N = len(b) - 1
-    artype = mintypecode((a, b))
+    xp = array_namespace(a, b)
+
+    a, b = map(xp.asarray, (a, b))
+    a, b = xp_promote(a, b, force_floating=True, xp=xp)
+    a = xpx.atleast_nd(a, ndim=1, xp=xp)
+    b = xpx.atleast_nd(b, ndim=1, xp=xp)
+
+    D = a.shape[0] - 1
+    N = b.shape[0] - 1
     M = max([N, D])
     Np = M + M
     Dp = M + M
-    bprime = np.empty(Np + 1, artype)
-    aprime = np.empty(Dp + 1, artype)
+    bprime = xp.empty(Np + 1, dtype=b.dtype)
+    aprime = xp.empty(Dp + 1, dtype=a.dtype)
     wosq = wo * wo
     for j in range(Np + 1):
         val = 0.0
@@ -2725,7 +2797,7 @@ def _relative_degree(z, p):
     """
     Return relative degree of transfer function from zeros and poles
     """
-    degree = len(p) - len(z)
+    degree = p.shape[0] - z.shape[0]
     if degree < 0:
         raise ValueError("Improper transfer function. "
                          "Must have at least as many poles as zeros.")
@@ -2795,8 +2867,11 @@ def bilinear_zpk(z, p, k, fs):
     >>> plt.ylabel('Amplitude [dB]')
     >>> plt.grid(True)
     """
-    z = atleast_1d(z)
-    p = atleast_1d(p)
+    xp = array_namespace(z, p)
+
+    z, p = map(xp.asarray, (z, p))
+    z = xpx.atleast_nd(z, ndim=1, xp=xp)
+    p = xpx.atleast_nd(p, ndim=1, xp=xp)
 
     fs = _validate_fs(fs, allow_none=False)
 
@@ -2809,10 +2884,10 @@ def bilinear_zpk(z, p, k, fs):
     p_z = (fs2 + p) / (fs2 - p)
 
     # Any zeros that were at infinity get moved to the Nyquist frequency
-    z_z = append(z_z, -ones(degree))
+    z_z = xp.concat((z_z, -xp.ones(degree)))
 
     # Compensate for gain change
-    k_z = k * real(prod(fs2 - z) / prod(fs2 - p))
+    k_z = k * xp.real(xp.prod(fs2 - z) / xp.prod(fs2 - p))
 
     return z_z, p_z, k_z
 
@@ -2872,8 +2947,12 @@ def lp2lp_zpk(z, p, k, wo=1.0):
     >>> lp2lp_zpk(z, p, k, wo)
     (   array([2.8, 0.8]), array([2. , 5.2]), 0.8)
     """
-    z = atleast_1d(z)
-    p = atleast_1d(p)
+    xp = array_namespace(z, p)
+
+    z, p = map(xp.asarray, (z, p))
+    z = xpx.atleast_nd(z, ndim=1, xp=xp)
+    p = xpx.atleast_nd(p, ndim=1, xp=xp)
+
     wo = float(wo)  # Avoid int wraparound
 
     degree = _relative_degree(z, p)
@@ -2949,8 +3028,13 @@ def lp2hp_zpk(z, p, k, wo=1.0):
         array([-0.6 , -0.15]),
         8.5)
     """
-    z = atleast_1d(z)
-    p = atleast_1d(p)
+    xp = array_namespace(z, p)
+
+    z, p = map(xp.asarray, (z, p))
+    # XXX: no xp_promote here since that breaks TestButter
+    z = xpx.atleast_nd(z, ndim=1, xp=xp)
+    p = xpx.atleast_nd(p, ndim=1, xp=xp)
+
     wo = float(wo)
 
     degree = _relative_degree(z, p)
@@ -2961,10 +3045,10 @@ def lp2hp_zpk(z, p, k, wo=1.0):
     p_hp = wo / p
 
     # If lowpass had zeros at infinity, inverting moves them to origin.
-    z_hp = append(z_hp, zeros(degree))
+    z_hp = xp.concat((z_hp, xp.zeros(degree)))
 
     # Cancel out gain change caused by inversion
-    k_hp = k * real(prod(-z) / prod(-p))
+    k_hp = k * xp.real(xp.prod(-z) / xp.prod(-p))
 
     return z_hp, p_hp, k_hp
 
@@ -3035,8 +3119,13 @@ def lp2bp_zpk(z, p, k, wo=1.0, bw=1.0):
         array([1.04996339e+02+0.j, -1.60167736e-03+0.j,  3.66108003e-03+0.j,
                -2.39998398e+02+0.j]), 0.8)
     """
-    z = atleast_1d(z)
-    p = atleast_1d(p)
+    xp = array_namespace(z, p)
+
+    z, p = map(xp.asarray, (z, p))
+    z, p = xp_promote(z, p, force_floating=True, xp=xp)
+    z = xpx.atleast_nd(z, ndim=1, xp=xp)
+    p = xpx.atleast_nd(p, ndim=1, xp=xp)
+
     wo = float(wo)
     bw = float(bw)
 
@@ -3047,17 +3136,17 @@ def lp2bp_zpk(z, p, k, wo=1.0, bw=1.0):
     p_lp = p * bw/2
 
     # Square root needs to produce complex result, not NaN
-    z_lp = z_lp.astype(complex)
-    p_lp = p_lp.astype(complex)
+    z_lp = xp.astype(z_lp, xp.complex128)
+    p_lp = xp.astype(p_lp, xp.complex128)
 
     # Duplicate poles and zeros and shift from baseband to +wo and -wo
-    z_bp = concatenate((z_lp + sqrt(z_lp**2 - wo**2),
-                        z_lp - sqrt(z_lp**2 - wo**2)))
-    p_bp = concatenate((p_lp + sqrt(p_lp**2 - wo**2),
-                        p_lp - sqrt(p_lp**2 - wo**2)))
+    z_bp = xp.concat((z_lp + xp.sqrt(z_lp**2 - wo**2),
+                      z_lp - xp.sqrt(z_lp**2 - wo**2)))
+    p_bp = xp.concat((p_lp + xp.sqrt(p_lp**2 - wo**2),
+                      p_lp - xp.sqrt(p_lp**2 - wo**2)))
 
     # Move degree zeros to origin, leaving degree zeros at infinity for BPF
-    z_bp = append(z_bp, zeros(degree))
+    z_bp = xp.concat((z_bp, xp.zeros(degree)))
 
     # Cancel out gain change from frequency scaling
     k_bp = k * bw**degree
@@ -3130,8 +3219,13 @@ def lp2bs_zpk(z, p, k, wo=1.0, bw=1.0):
         array([14.2681928 +0.j, -0.02506281+0.j,  0.01752149+0.j, -9.97493719+0.j]),
         -12.857142857142858)
     """
-    z = atleast_1d(z)
-    p = atleast_1d(p)
+    xp = array_namespace(z, p)
+
+    z, p = map(xp.asarray, (z, p))
+    z, p = xp_promote(z, p, force_floating=True, xp=xp)
+    z = xpx.atleast_nd(z, ndim=1, xp=xp)
+    p = xpx.atleast_nd(p, ndim=1, xp=xp)
+
     wo = float(wo)
     bw = float(bw)
 
@@ -3142,21 +3236,21 @@ def lp2bs_zpk(z, p, k, wo=1.0, bw=1.0):
     p_hp = (bw/2) / p
 
     # Square root needs to produce complex result, not NaN
-    z_hp = z_hp.astype(complex)
-    p_hp = p_hp.astype(complex)
+    z_hp = xp.astype(z_hp, xp.complex128)
+    p_hp = xp.astype(p_hp, xp.complex128)
 
     # Duplicate poles and zeros and shift from baseband to +wo and -wo
-    z_bs = concatenate((z_hp + sqrt(z_hp**2 - wo**2),
-                        z_hp - sqrt(z_hp**2 - wo**2)))
-    p_bs = concatenate((p_hp + sqrt(p_hp**2 - wo**2),
-                        p_hp - sqrt(p_hp**2 - wo**2)))
+    z_bs = xp.concat((z_hp + xp.sqrt(z_hp**2 - wo**2),
+                      z_hp - xp.sqrt(z_hp**2 - wo**2)))
+    p_bs = xp.concat((p_hp + xp.sqrt(p_hp**2 - wo**2),
+                      p_hp - xp.sqrt(p_hp**2 - wo**2)))
 
     # Move any zeros that were at infinity to the center of the stopband
-    z_bs = append(z_bs, full(degree, +1j*wo))
-    z_bs = append(z_bs, full(degree, -1j*wo))
+    z_bs = xp.concat((z_bs, xp.full(degree, +1j*wo)))
+    z_bs = xp.concat((z_bs, xp.full(degree, -1j*wo)))
 
     # Cancel out gain change caused by inversion
-    k_bs = k * real(prod(-z) / prod(-p))
+    k_bs = k * xp.real(xp.prod(-z) / xp.prod(-p))
 
     return z_bs, p_bs, k_bs
 
diff --git a/scipy/signal/tests/test_filter_design.py b/scipy/signal/tests/test_filter_design.py
index 558d61110729..0a59780dee22 100644
--- a/scipy/signal/tests/test_filter_design.py
+++ b/scipy/signal/tests/test_filter_design.py
@@ -1,3 +1,5 @@
+import math
+import cmath
 import warnings
 
 from itertools import product
@@ -14,7 +16,7 @@
     assert_array_almost_equal,
 )
 
-from numpy import array, spacing, sin, pi, sort, sqrt
+from numpy import array, spacing, sin, pi, sort
 from scipy.signal import (argrelextrema, BadCoefficients, bessel, besselap, bilinear,
                           buttap, butter, buttord, cheb1ap, cheb1ord, cheb2ap,
                           cheb2ord, cheby1, cheby2, ellip, ellipap, ellipord,
@@ -27,6 +29,9 @@
 from scipy.signal._filter_design import (_cplxreal, _cplxpair, _norm_factor,
                                         _bessel_poly, _bessel_zeros)
 
+skip_xp_backends = pytest.mark.skip_xp_backends
+xfail_xp_backends = pytest.mark.xfail_xp_backends
+
 
 try:
     import mpmath
@@ -1351,43 +1356,53 @@ def test_errors(self):
 
 class TestLp2lp:
 
-    def test_basic(self):
-        b = [1]
-        a = [1, np.sqrt(2), 1]
+    def test_basic(self, xp):
+        b = xp.asarray([1])
+        a = xp.asarray([1, math.sqrt(2), 1])
         b_lp, a_lp = lp2lp(b, a, 0.38574256627112119)
-        assert_array_almost_equal(b_lp, [0.1488], decimal=4)
-        assert_array_almost_equal(a_lp, [1, 0.5455, 0.1488], decimal=4)
+        assert_array_almost_equal(b_lp, xp.asarray([0.1488]), decimal=4)
+        assert_array_almost_equal(a_lp, xp.asarray([1, 0.5455, 0.1488]), decimal=4)
 
 
 class TestLp2hp:
 
-    def test_basic(self):
-        b = [0.25059432325190018]
-        a = [1, 0.59724041654134863, 0.92834805757524175, 0.25059432325190018]
-        b_hp, a_hp = lp2hp(b, a, 2*np.pi*5000)
-        xp_assert_close(b_hp, [1.0, 0, 0, 0])
-        xp_assert_close(a_hp, [1, 1.1638e5, 2.3522e9, 1.2373e14], rtol=1e-4)
+    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
+    def test_basic(self, xp):
+        b = xp.asarray([0.25059432325190018])
+        a = xp.asarray(
+            [1, 0.59724041654134863, 0.92834805757524175, 0.25059432325190018]
+        )
+        b_hp, a_hp = lp2hp(b, a, 2*math.pi*5000)
+        xp_assert_close(b_hp, xp.asarray([1.0, 0, 0, 0]))
+        xp_assert_close(
+            a_hp, xp.asarray([1, 1.1638e5, 2.3522e9, 1.2373e14]), rtol=1e-4
+        )
 
 
 class TestLp2bp:
 
-    def test_basic(self):
-        b = [1]
-        a = [1, 2, 2, 1]
-        b_bp, a_bp = lp2bp(b, a, 2*np.pi*4000, 2*np.pi*2000)
-        xp_assert_close(b_bp, [1.9844e12, 0, 0, 0], rtol=1e-6)
-        xp_assert_close(a_bp, [1, 2.5133e4, 2.2108e9, 3.3735e13,
-                               1.3965e18, 1.0028e22, 2.5202e26], rtol=1e-4)
+    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
+    def test_basic(self, xp):
+        b = xp.asarray([1])
+        a = xp.asarray([1, 2, 2, 1])
+        b_bp, a_bp = lp2bp(b, a, 2*math.pi*4000, 2*math.pi*2000)
+        xp_assert_close(b_bp, xp.asarray([1.9844e12, 0, 0, 0]), rtol=1e-6)
+        xp_assert_close(
+            a_bp,
+            xp.asarray([1, 2.5133e4, 2.2108e9, 3.3735e13,
+                        1.3965e18, 1.0028e22, 2.5202e26]), rtol=1e-4
+        )
 
 
 class TestLp2bs:
 
-    def test_basic(self):
-        b = [1]
-        a = [1, 1]
+    @skip_xp_backends(eager_only=True, reason="in-place item assignment")
+    def test_basic(self, xp):
+        b = xp.asarray([1])
+        a = xp.asarray([1, 1])
         b_bs, a_bs = lp2bs(b, a, 0.41722257286366754, 0.18460575326152251)
-        assert_array_almost_equal(b_bs, [1, 0, 0.17407], decimal=5)
-        assert_array_almost_equal(a_bs, [1, 0.18461, 0.17407], decimal=5)
+        assert_array_almost_equal(b_bs, xp.asarray([1, 0, 0.17407]), decimal=5)
+        assert_array_almost_equal(a_bs, xp.asarray([1, 0.18461, 0.17407]), decimal=5)
 
 
 class TestBilinear:
@@ -1480,25 +1495,45 @@ def test_fs_validation(self):
             bilinear(b, a, fs=None)
 
 
+def _sort_cmplx(arr, xp):
+    # xp.sort is undefined for complex dtypes. Here we only need some
+    # consistent way to sort a complex array, including equal magnitude elements.
+    arr = xp.asarray(arr)
+    if xp.isdtype(arr.dtype, 'complex floating'):
+        sorter = abs(arr) + xp.real(arr) + xp.imag(arr)**3
+    else:
+        sorter = arr
+
+    idxs = xp.argsort(sorter)
+    return arr[idxs]
+
+
 class TestLp2lp_zpk:
 
-    def test_basic(self):
-        z = []
-        p = [(-1+1j)/np.sqrt(2), (-1-1j)/np.sqrt(2)]
+    @xfail_xp_backends(
+        'dask.array', reason='https://github.com/dask/dask/issues/11883'
+    )
+    def test_basic(self, xp):
+        z = xp.asarray([])
+        p = xp.asarray([(-1+1j) / math.sqrt(2), (-1-1j) / math.sqrt(2)])
         k = 1
         z_lp, p_lp, k_lp = lp2lp_zpk(z, p, k, 5)
-        xp_assert_equal(z_lp, [])
-        xp_assert_close(sort(p_lp), sort(p)*5)
-        xp_assert_close(k_lp, 25.)
+        xp_assert_equal(z_lp, xp.asarray([]))
+        xp_assert_close(_sort_cmplx(p_lp, xp=xp), _sort_cmplx(p, xp=xp) * 5)
+        assert k_lp == 25.
 
         # Pseudo-Chebyshev with both poles and zeros
-        z = [-2j, +2j]
-        p = [-0.75, -0.5-0.5j, -0.5+0.5j]
+        z = xp.asarray([-2j, +2j])
+        p = xp.asarray([-0.75, -0.5-0.5j, -0.5+0.5j])
         k = 3
         z_lp, p_lp, k_lp = lp2lp_zpk(z, p, k, 20)
-        xp_assert_close(sort(z_lp), sort([-40j, +40j]))
-        xp_assert_close(sort(p_lp), sort([-15, -10-10j, -10+10j]))
-        xp_assert_close(k_lp, 60.)
+        xp_assert_close(
+            _sort_cmplx(z_lp, xp=xp), _sort_cmplx([-40j, +40j], xp=xp)
+        )
+        xp_assert_close(
+            _sort_cmplx(p_lp, xp=xp), _sort_cmplx([-15, -10-10j, -10+10j], xp=xp)
+        )
+        assert k_lp == 60.
 
     def test_fs_validation(self):
         z = [-2j, +2j]
@@ -1514,80 +1549,115 @@ def test_fs_validation(self):
 
 class TestLp2hp_zpk:
 
-    def test_basic(self):
-        z = []
-        p = [(-1+1j)/np.sqrt(2), (-1-1j)/np.sqrt(2)]
+    @xfail_xp_backends(
+        'dask.array', reason='https://github.com/dask/dask/issues/11883'
+    )
+    def test_basic(self, xp):
+        z = xp.asarray([])
+        p = xp.asarray([(-1+1j) / math.sqrt(2), (-1-1j) / math.sqrt(2)])
         k = 1
 
         z_hp, p_hp, k_hp = lp2hp_zpk(z, p, k, 5)
-        xp_assert_equal(z_hp, np.asarray([0.0, 0.0]))
-        xp_assert_close(sort(p_hp), sort(p)*5)
-        xp_assert_close(k_hp, 1.0)
+        xp_assert_equal(z_hp, xp.asarray([0.0, 0.0], dtype=z_hp.dtype))
+        xp_assert_close(_sort_cmplx(p_hp, xp=xp), _sort_cmplx(p, xp=xp) * 5)
+        assert math.isclose(k_hp, 1.0, rel_tol=4e-7)
 
-        z = [-2j, +2j]
-        p = [-0.75, -0.5-0.5j, -0.5+0.5j]
+        z = xp.asarray([-2j, +2j])
+        p = xp.asarray([-0.75, -0.5-0.5j, -0.5+0.5j])
         k = 3
         z_hp, p_hp, k_hp = lp2hp_zpk(z, p, k, 6)
-        xp_assert_close(sort(z_hp), sort([-3j, 0, +3j]))
-        xp_assert_close(sort(p_hp), sort([-8, -6-6j, -6+6j]))
-        xp_assert_close(k_hp, 32.0)
+        xp_assert_close(
+            _sort_cmplx(z_hp, xp=xp), _sort_cmplx([-3j, 0, +3j], xp=xp)
+        )
+        xp_assert_close(
+            _sort_cmplx(p_hp, xp=xp), _sort_cmplx([-8, -6-6j, -6+6j], xp=xp)
+        )
+        assert k_hp == 32.0
 
 
 class TestLp2bp_zpk:
 
-    def test_basic(self):
-        z = [-2j, +2j]
-        p = [-0.75, -0.5-0.5j, -0.5+0.5j]
+    @xfail_xp_backends(
+        'dask.array', reason='https://github.com/dask/dask/issues/11883'
+    )
+    def test_basic(self, xp):
+        z = xp.asarray([-2j, +2j])
+        p = xp.asarray([-0.75, -0.5-0.5j, -0.5+0.5j])
         k = 3
         z_bp, p_bp, k_bp = lp2bp_zpk(z, p, k, 15, 8)
-        xp_assert_close(sort(z_bp), sort([-25j, -9j, 0, +9j, +25j]))
-        xp_assert_close(sort(p_bp), sort([-3 + 6j*sqrt(6),
-                                          -3 - 6j*sqrt(6),
-                                          +2j+sqrt(-8j-225)-2,
-                                          -2j+sqrt(+8j-225)-2,
-                                          +2j-sqrt(-8j-225)-2,
-                                          -2j-sqrt(+8j-225)-2, ]))
-        xp_assert_close(k_bp, 24.0)
+        xp_assert_close(
+            _sort_cmplx(z_bp, xp=xp),
+            _sort_cmplx([-25j, -9j, 0, +9j, +25j], xp=xp), check_dtype=False
+        )
+        xp_assert_close(
+            _sort_cmplx(p_bp, xp=xp),
+            _sort_cmplx(
+                [-3 + 6j*math.sqrt(6), -3 - 6j*math.sqrt(6),
+                 +2j + cmath.sqrt(-8j - 225) - 2, -2j + cmath.sqrt(+8j - 225) - 2,
+                 +2j - cmath.sqrt(-8j - 225) - 2, -2j - cmath.sqrt(+8j - 225) - 2
+                ], xp=xp
+            ), check_dtype=False
+        )
+        assert math.isclose(k_bp, 24.0)
 
 
 class TestLp2bs_zpk:
 
-    def test_basic(self):
-        z = [-2j, +2j]
-        p = [-0.75, -0.5-0.5j, -0.5+0.5j]
+    @xfail_xp_backends(
+        'dask.array', reason='https://github.com/dask/dask/issues/11883'
+    )
+    def test_basic(self, xp):
+        z = xp.asarray([-2j, +2j])
+        p = xp.asarray([-0.75, -0.5-0.5j, -0.5+0.5j])
         k = 3
 
         z_bs, p_bs, k_bs = lp2bs_zpk(z, p, k, 35, 12)
 
-        xp_assert_close(sort(z_bs), sort([+35j, -35j,
-                                          +3j+sqrt(1234)*1j,
-                                          -3j+sqrt(1234)*1j,
-                                          +3j-sqrt(1234)*1j,
-                                          -3j-sqrt(1234)*1j]))
-        xp_assert_close(sort(p_bs), sort([+3j*sqrt(129) - 8,
-                                          -3j*sqrt(129) - 8,
-                                          (-6 + 6j) - sqrt(-1225 - 72j),
-                                          (-6 - 6j) - sqrt(-1225 + 72j),
-                                          (-6 + 6j) + sqrt(-1225 - 72j),
-                                          (-6 - 6j) + sqrt(-1225 + 72j), ]))
-        xp_assert_close(k_bs, 32.0)
+        xp_assert_close(
+            _sort_cmplx(z_bs, xp=xp),
+            _sort_cmplx([+35j, -35j,
+                         +3j + math.sqrt(1234)*1j,
+                         -3j + math.sqrt(1234)*1j,
+                         +3j - math.sqrt(1234)*1j,
+                         -3j - math.sqrt(1234)*1j], xp=xp), check_dtype=False
+        )
+        xp_assert_close(
+            _sort_cmplx(p_bs, xp=xp),
+            _sort_cmplx([+3j*math.sqrt(129) - 8,
+                         -3j*math.sqrt(129) - 8,
+                         (-6 + 6j) - cmath.sqrt(-1225 - 72j),
+                         (-6 - 6j) - cmath.sqrt(-1225 + 72j),
+                         (-6 + 6j) + cmath.sqrt(-1225 - 72j),
+                         (-6 - 6j) + cmath.sqrt(-1225 + 72j), ], xp=xp),
+            check_dtype=False
+        )
+        assert math.isclose(k_bs, 32.0)
 
 
 class TestBilinear_zpk:
 
-    def test_basic(self):
-        z = [-2j, +2j]
-        p = [-0.75, -0.5-0.5j, -0.5+0.5j]
+    @xfail_xp_backends(
+        'dask.array', reason='https://github.com/dask/dask/issues/11883'
+    )
+    def test_basic(self, xp):
+        z = xp.asarray([-2j, +2j])
+        p = xp.asarray([-0.75, -0.5-0.5j, -0.5+0.5j])
         k = 3
 
         z_d, p_d, k_d = bilinear_zpk(z, p, k, 10)
 
-        xp_assert_close(sort(z_d), sort([(20-2j)/(20+2j), (20+2j)/(20-2j),
-                                         -1]))
-        xp_assert_close(sort(p_d), sort([77/83,
-                                         (1j/2 + 39/2) / (41/2 - 1j/2),
-                                         (39/2 - 1j/2) / (1j/2 + 41/2), ]))
-        xp_assert_close(k_d, 9696/69803)
+        xp_assert_close(
+            _sort_cmplx(z_d, xp=xp),
+            _sort_cmplx([(20-2j) / (20+2j), (20+2j) / (20-2j), -1], xp=xp)
+        )
+        xp_assert_close(
+            _sort_cmplx(p_d, xp=xp),
+            _sort_cmplx(
+                [77/83, (1j/2 + 39/2) / (41/2 - 1j/2), (39/2 - 1j/2) / (1j/2 + 41/2)],
+                xp=xp
+            )
+        )
+        assert math.isclose(k_d, 9696/69803, rel_tol=4e-7)
 
 
 class TestPrototypeType:
diff --git a/scipy/signal/tests/test_signaltools.py b/scipy/signal/tests/test_signaltools.py
index 3f4732a536d8..b63a6211fcf5 100644
--- a/scipy/signal/tests/test_signaltools.py
+++ b/scipy/signal/tests/test_signaltools.py
@@ -485,7 +485,7 @@ def test_consistency_convolve_funcs(self, xp):
             )
             xp_assert_close(
                 xp.squeeze(
-                    signal.convolve2d(xp.asarray([a]), xp.asarray([b]), mode=mode),
+                    signal.convolve2d(a[None, :], b[None, :], mode=mode),
                     axis=0
                 ),
                 signal.convolve(a, b, mode=mode)
@@ -4154,7 +4154,8 @@ def test_rank1(self, dt, xp):
 
         # Test simple IIR
         y_r = xp.asarray([0, 2, 4, 6, 8, 10.], dtype=dt)
-        sos = tf2sos(b, a)
+        bb, aa = map(np.asarray, (b, a))
+        sos = tf2sos(bb, aa)
         sos = xp.asarray(sos)   # XXX while tf2sos is numpy only
         assert_array_almost_equal(sosfilt(sos, x), y_r)
 
@@ -4163,7 +4164,8 @@ def test_rank1(self, dt, xp):
         # NOTE: This was changed (rel. to TestLinear...) to add a pole @zero:
         a = xp.asarray([1, 0], dtype=dt)
         y_r = xp.asarray([0, 1, 3, 5, 7, 9.], dtype=dt)
-        sos = tf2sos(b, a)
+        bb, aa = map(np.asarray, (b, a))
+        sos = tf2sos(bb, aa)
         sos = xp.asarray(sos)   # XXX while tf2sos is numpy only
         assert_array_almost_equal(sosfilt(sos, x), y_r)
 
@@ -4193,12 +4195,13 @@ def test_rank2(self, dt, xp):
         y_r2_a1 = xp.asarray([[0, 2, 0], [6, -4, 6], [12, -10, 12],
                             [18, -16, 18]], dtype=dt)
 
-        sos = tf2sos(b, a)
+        bb, aa = map(np.asarray, (b, a))
+        sos = tf2sos(bb, aa)
         sos = xp.asarray(sos)   # XXX
         y = sosfilt(sos, x, axis=0)
         assert_array_almost_equal(y_r2_a0, y)
 
-        sos = tf2sos(b, a)
+        sos = tf2sos(bb, aa)
         sos = xp.asarray(sos)   # XXX
         y = sosfilt(sos, x, axis=1)
         assert_array_almost_equal(y_r2_a1, y)
@@ -4215,7 +4218,8 @@ def test_rank3(self, dt, xp):
         a = xp.asarray([0.5, 0.5], dtype=dt)
 
         # Test last axis
-        sos = tf2sos(b, a)
+        bb, aa = map(np.asarray, (b, a))  # XXX until tf2sos is array api compatible
+        sos = tf2sos(bb, aa)
         sos = xp.asarray(sos)   # XXX
         y = sosfilt(sos, x)
         for i in range(x.shape[0]):

```
