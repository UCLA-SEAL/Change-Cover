## [PR 60637](https://github.com/pandas-dev/pandas/pull/60637)

## PR Summary

This pull request (PR #60637) addresses a bug in the pandas library's interpolation method for string data types by raising a proper TypeError. The changes include resolving expected failures in tests related to string dtype, adjusting tests for arrow compatibility, and refactoring code for NumPy extension arrays. New tests have been added, ensuring better error handling and robustness in the interpolation functionality.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# pandas/core/arrays/arrow/array.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/core/arrays/numpy_.py
--------------------------------------------------------------------------------
class NumpyExtensionArray(  # type: ignore[misc]
    OpsMixin,
    NDArrayBackedExtensionArray,
    ObjectStringArrayMixin,
):
...
    def __init__(
        self, values: np.ndarray | NumpyExtensionArray, copy: bool = False
    ) -> None:
...
    def _from_sequence(
        cls, scalars, *, dtype: Dtype | None = None, copy: bool = False
    ) -> NumpyExtensionArray:
...
    def dtype(self) -> NumpyEADtype:
...
    def __array__(
        self, dtype: NpDtype | None = None, copy: bool | None = None
    ) -> np.ndarray:
...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs):
        # Lightly modified version of
        # https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html
        # The primary modification is not boxing scalar return values
        # in NumpyExtensionArray, since pandas' ExtensionArrays are 1-d.
...
    def astype(self, dtype, copy: bool = True):
...
    def isna(self) -> np.ndarray:
...
    def _validate_scalar(self, fill_value):
...
    def _values_for_factorize(self) -> tuple[np.ndarray, float | None]:
...
    def _pad_or_backfill(
        self,
        *,
        method: FillnaOptions,
        limit: int | None = None,
        limit_area: Literal["inside", "outside"] | None = None,
        copy: bool = True,
    ) -> Self:
...
    def interpolate(
        self,
        *,
        method: InterpolateOptions,
        axis: int,
        index: Index,
        limit,
        limit_direction,
        limit_area,
        copy: bool,
        **kwargs,
    ) -> Self:
        """
        See NDFrame.interpolate.__doc__.
        """
        # NB: we return type(self) even if copy=False
        if not self.dtype._is_numeric:
            raise TypeError(f"Cannot interpolate with {self.dtype} dtype") #â—UNCOVERED: NEED TEST

        if not copy:
            out_data = self._ndarray
        else:
            out_data = self._ndarray.copy()

        # TODO: assert we have floating dtype?
        missing.interpolate_2d_inplace(
            out_data,
            method=method,
...
    def any(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def all(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def min(
        self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs
    ) -> Scalar:
...
    def max(
        self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs
    ) -> Scalar:
...
    def sum(
        self,
        *,
        axis: AxisInt | None = None,
        skipna: bool = True,
        min_count: int = 0,
        **kwargs,
    ) -> Scalar:
...
    def prod(
        self,
        *,
        axis: AxisInt | None = None,
        skipna: bool = True,
        min_count: int = 0,
        **kwargs,
    ) -> Scalar:
...
    def mean(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def median(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        overwrite_input: bool = False,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def std(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def var(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def sem(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def kurt(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def skew(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def to_numpy(
        self,
        dtype: npt.DTypeLike | None = None,
        copy: bool = False,
        na_value: object = lib.no_default,
    ) -> np.ndarray:
...
    def __invert__(self) -> NumpyExtensionArray:
...
    def __neg__(self) -> NumpyExtensionArray:
...
    def __pos__(self) -> NumpyExtensionArray:
...
    def __abs__(self) -> NumpyExtensionArray:
...
    def _cmp_method(self, other, op):
...
    def _wrap_ndarray_result(self, result: np.ndarray):
        # If we have timedelta64[ns] result, return a TimedeltaArray instead
        #  of a NumpyExtensionArray

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/extension/test_arrow.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/frame/methods/test_interpolate.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/pandas/core/arrays/arrow/array.py b/pandas/core/arrays/arrow/array.py
index afa219f611992..4d9c8eb3a41b6 100644
--- a/pandas/core/arrays/arrow/array.py
+++ b/pandas/core/arrays/arrow/array.py
@@ -2160,7 +2160,7 @@ def interpolate(
         """
         # NB: we return type(self) even if copy=False
         if not self.dtype._is_numeric:
-            raise ValueError("Values must be numeric.")
+            raise TypeError(f"Cannot interpolate with {self.dtype} dtype")
 
         if (
             not pa_version_under13p0
diff --git a/pandas/core/arrays/numpy_.py b/pandas/core/arrays/numpy_.py
index 9f7238a97d808..07fa6254d87f3 100644
--- a/pandas/core/arrays/numpy_.py
+++ b/pandas/core/arrays/numpy_.py
@@ -287,6 +287,9 @@ def interpolate(
         See NDFrame.interpolate.__doc__.
         """
         # NB: we return type(self) even if copy=False
+        if not self.dtype._is_numeric:
+            raise TypeError(f"Cannot interpolate with {self.dtype} dtype")
+
         if not copy:
             out_data = self._ndarray
         else:
diff --git a/pandas/tests/extension/test_arrow.py b/pandas/tests/extension/test_arrow.py
index 6dd1f3f15bc15..c5f5a65b77eea 100644
--- a/pandas/tests/extension/test_arrow.py
+++ b/pandas/tests/extension/test_arrow.py
@@ -3451,7 +3451,9 @@ def test_string_to_datetime_parsing_cast():
 )
 def test_interpolate_not_numeric(data):
     if not data.dtype._is_numeric:
-        with pytest.raises(ValueError, match="Values must be numeric."):
+        ser = pd.Series(data)
+        msg = re.escape(f"Cannot interpolate with {ser.dtype} dtype")
+        with pytest.raises(TypeError, match=msg):
             pd.Series(data).interpolate()
 
 
diff --git a/pandas/tests/frame/methods/test_interpolate.py b/pandas/tests/frame/methods/test_interpolate.py
index b8a34d5eaa226..09d1cc9a479b2 100644
--- a/pandas/tests/frame/methods/test_interpolate.py
+++ b/pandas/tests/frame/methods/test_interpolate.py
@@ -64,11 +64,7 @@ def test_interpolate_inplace(self, frame_or_series, request):
         assert np.shares_memory(orig, obj.values)
         assert orig.squeeze()[1] == 1.5
 
-    # TODO(infer_string) raise proper TypeError in case of string dtype
-    @pytest.mark.xfail(
-        using_string_dtype(), reason="interpolate doesn't work for string"
-    )
-    def test_interp_basic(self):
+    def test_interp_basic(self, using_infer_string):
         df = DataFrame(
             {
                 "A": [1, 2, np.nan, 4],
@@ -77,7 +73,8 @@ def test_interp_basic(self):
                 "D": list("abcd"),
             }
         )
-        msg = "DataFrame cannot interpolate with object dtype"
+        dtype = "str" if using_infer_string else "object"
+        msg = f"[Cc]annot interpolate with {dtype} dtype"
         with pytest.raises(TypeError, match=msg):
             df.interpolate()
 
@@ -87,8 +84,8 @@ def test_interp_basic(self):
             df.interpolate(inplace=True)
 
         # check we DID operate inplace
-        assert np.shares_memory(df["C"]._values, cvalues)
-        assert np.shares_memory(df["D"]._values, dvalues)
+        assert tm.shares_memory(df["C"]._values, cvalues)
+        assert tm.shares_memory(df["D"]._values, dvalues)
 
     @pytest.mark.xfail(
         using_string_dtype(), reason="interpolate doesn't work for string"

```
