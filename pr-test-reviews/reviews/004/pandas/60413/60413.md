## [PR 60413](https://github.com/pandas-dev/pandas/pull/60413)

## PR Summary

This PR addresses a NameError that occurs when specifying a dtype with a string containing '[pyarrow]' while PyArrow is not installed. It includes 8 commits that fix the bug, improve error messaging, and add relevant tests. The changes enhance user guidance regarding optional dependencies, aligning with the installation documentation for Pandas.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# pandas/core/dtypes/dtypes.py
--------------------------------------------------------------------------------
class PandasExtensionDtype(ExtensionDtype):
...
    def __repr__(self) -> str_type:
...
    def __hash__(self) -> int:
...
    def __getstate__(self) -> dict[str_type, Any]:
        # pickle support; we don't want to pickle the cache
...
    def reset_cache(cls) -> None:
...
class CategoricalDtypeType(type):
...
class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
...
    def __init__(self, categories=None, ordered: Ordered = False) -> None:
...
    def _from_fastpath(
        cls, categories=None, ordered: bool | None = None
    ) -> CategoricalDtype:
...
    def _from_categorical_dtype(
        cls, dtype: CategoricalDtype, categories=None, ordered: Ordered | None = None
    ) -> CategoricalDtype:
...
    def _from_values_or_dtype(
        cls,
        values=None,
        categories=None,
        ordered: bool | None = None,
        dtype: Dtype | None = None,
    ) -> CategoricalDtype:
...
    def construct_from_string(cls, string: str_type) -> CategoricalDtype:
...
    def _finalize(self, categories, ordered: Ordered, fastpath: bool = False) -> None:
...
    def __setstate__(self, state: MutableMapping[str_type, Any]) -> None:
        # for pickle compat. __get_state__ is defined in the
        # PandasExtensionDtype superclass and uses the public properties to
        # pickle -> need to set the settable private ones here (see GH26067)
...
    def __hash__(self) -> int:
        # _hash_categories returns a uint64, so use the negative
        # space for when we have unknown categories to avoid a conflict
...
    def __eq__(self, other: object) -> bool:
...
    def __repr__(self) -> str_type:
...
    def _hash_categories(self) -> int:
...
    def construct_array_type(cls) -> type_t[Categorical]:
...
    def validate_ordered(ordered: Ordered) -> None:
...
    def validate_categories(categories, fastpath: bool = False) -> Index:
...
    def update_dtype(self, dtype: str_type | CategoricalDtype) -> CategoricalDtype:
...
    def categories(self) -> Index:
...
    def ordered(self) -> Ordered:
...
    def _is_boolean(self) -> bool:
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
        # check if we have all categorical dtype with identical categories
...
    def index_class(self) -> type_t[CategoricalIndex]:
...
class DatetimeTZDtype(PandasExtensionDtype):
...
    def na_value(self) -> NaTType:
...
    def base(self) -> DtypeObj:  # type: ignore[override]
...
    def str(self) -> str:  # type: ignore[override]
...
    def __init__(self, unit: str_type | DatetimeTZDtype = "ns", tz=None) -> None:
...
    def _creso(self) -> int:
...
    def unit(self) -> str_type:
...
    def tz(self) -> tzinfo:
...
    def construct_array_type(cls) -> type_t[DatetimeArray]:
...
    def construct_from_string(cls, string: str_type) -> DatetimeTZDtype:
...
    def __str__(self) -> str_type:
...
    def name(self) -> str_type:
...
    def __hash__(self) -> int:
        # make myself hashable
        # TODO: update this.
...
    def __eq__(self, other: object) -> bool:
...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> DatetimeArray:
...
    def __setstate__(self, state) -> None:
        # for pickle compat. __get_state__ is defined in the
        # PandasExtensionDtype superclass and uses the public properties to
        # pickle -> need to set the settable private ones here (see GH26067)
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
...
    def index_class(self) -> type_t[DatetimeIndex]:
...
class PeriodDtype(PeriodDtypeBase, PandasExtensionDtype):
...
    def __new__(cls, freq) -> PeriodDtype:  # noqa: PYI034
...
    def __reduce__(self) -> tuple[type_t[Self], tuple[str_type]]:
...
    def freq(self) -> BaseOffset:
...
    def _parse_dtype_strict(cls, freq: str_type) -> BaseOffset:
...
    def construct_from_string(cls, string: str_type) -> PeriodDtype:
...
    def __str__(self) -> str_type:
...
    def name(self) -> str_type:
...
    def na_value(self) -> NaTType:
...
    def __eq__(self, other: object) -> bool:
...
    def __ne__(self, other: object) -> bool:
...
    def is_dtype(cls, dtype: object) -> bool:
...
    def construct_array_type(cls) -> type_t[PeriodArray]:
...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> PeriodArray:
...
    def index_class(self) -> type_t[PeriodIndex]:
...
class IntervalDtype(PandasExtensionDtype):
...
    def __init__(self, subtype=None, closed: IntervalClosedType | None = None) -> None:
...
    def _can_hold_na(self) -> bool:
...
    def closed(self) -> IntervalClosedType:
...
    def subtype(self):
...
    def construct_array_type(cls) -> type[IntervalArray]:
...
    def construct_from_string(cls, string: str_type) -> IntervalDtype:
...
    def type(self) -> type[Interval]:
...
    def __str__(self) -> str_type:
...
    def __hash__(self) -> int:
        # make myself hashable
...
    def __eq__(self, other: object) -> bool:
...
    def __setstate__(self, state) -> None:
        # for pickle compat. __get_state__ is defined in the
        # PandasExtensionDtype superclass and uses the public properties to
        # pickle -> need to set the settable private ones here (see GH26067)
...
    def is_dtype(cls, dtype: object) -> bool:
...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> IntervalArray:
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
...
    def index_class(self) -> type_t[IntervalIndex]:
...
class NumpyEADtype(ExtensionDtype):
...
    def __init__(self, dtype: npt.DTypeLike | NumpyEADtype | None) -> None:
...
    def __repr__(self) -> str:
...
    def numpy_dtype(self) -> np.dtype:
...
    def name(self) -> str:
...
    def type(self) -> type[np.generic]:
...
    def _is_numeric(self) -> bool:
        # exclude object, str, unicode, void.
...
    def _is_boolean(self) -> bool:
...
    def construct_from_string(cls, string: str) -> NumpyEADtype:
...
    def construct_array_type(cls) -> type_t[NumpyExtensionArray]:
...
    def kind(self) -> str:
...
    def itemsize(self) -> int:
...
class BaseMaskedDtype(ExtensionDtype):
...
    def _truthy_value(self):
        # Fill values used for 'any'
...
    def _falsey_value(self):
        # Fill values used for 'all'
...
    def na_value(self) -> libmissing.NAType:
...
    def numpy_dtype(self) -> np.dtype:
...
    def kind(self) -> str:
...
    def itemsize(self) -> int:
...
    def construct_array_type(cls) -> type_t[BaseMaskedArray]:
...
    def from_numpy_dtype(cls, dtype: np.dtype) -> BaseMaskedDtype:
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
        # We unwrap any masked dtypes, find the common dtype we would use
        #  for that, then re-mask the result.
...
class SparseDtype(ExtensionDtype):
...
    def __init__(self, dtype: Dtype = np.float64, fill_value: Any = None) -> None:
...
    def __hash__(self) -> int:
        # Python3 doesn't inherit __hash__ when a base class overrides
        # __eq__, so we explicitly do it here.
...
    def __eq__(self, other: object) -> bool:
        # We have to override __eq__ to handle NA values in _metadata.
        # The base class does simple == checks, which fail for NA.
...
    def fill_value(self):
...
    def _check_fill_value(self) -> None:
...
    def _is_na_fill_value(self) -> bool:
...
    def _is_numeric(self) -> bool:
...
    def _is_boolean(self) -> bool:
...
    def kind(self) -> str:
...
    def type(self):
...
    def subtype(self):
...
    def name(self) -> str:
...
    def __repr__(self) -> str:
...
    def construct_array_type(cls) -> type_t[SparseArray]:
...
    def construct_from_string(cls, string: str) -> SparseDtype:
...
    def _parse_subtype(dtype: str) -> tuple[str, bool]:
...
    def is_dtype(cls, dtype: object) -> bool:
...
    def update_dtype(self, dtype) -> SparseDtype:
...
    def _subtype_with_str(self):
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
        # TODO for now only handle SparseDtypes and numpy dtypes => extend
        # with other compatible extension dtypes
...
class ArrowDtype(StorageExtensionDtype):
...
    def __init__(self, pyarrow_dtype: pa.DataType) -> None:
...
    def __repr__(self) -> str:
...
    def __hash__(self) -> int:
        # make myself hashable
...
    def __eq__(self, other: object) -> bool:
...
    def type(self):
...
    def name(self) -> str:  # type: ignore[override]
...
    def numpy_dtype(self) -> np.dtype:
...
    def kind(self) -> str:
...
    def itemsize(self) -> int:
...
    def construct_array_type(cls) -> type_t[ArrowExtensionArray]:
...
    def construct_from_string(cls, string: str) -> ArrowDtype:
...
        if not isinstance(string, str):
            raise TypeError(
                f"'construct_from_string' expects a string, got {type(string)}"
            )
        if not string.endswith("[pyarrow]"):
            raise TypeError(f"'{string}' must end with '[pyarrow]'")
        if string == "string[pyarrow]":
            # Ensure Registry.find skips ArrowDtype to use StringDtype instead
            raise TypeError("string[pyarrow] should be constructed by StringDtype")
        if pa_version_under10p1:
            raise ImportError("pyarrow>=10.0.1 is required for ArrowDtype") #❗UNCOVERED: NEED TEST

        base_type = string[:-9]  # get rid of "[pyarrow]"
        try:
            pa_dtype = pa.type_for_alias(base_type)
        except ValueError as err:
            has_parameters = re.search(r"[\[\(].*[\]\)]", base_type)
            if has_parameters:
                # Fallback to try common temporal types
                try:
                    return cls._parse_temporal_dtype_string(base_type)
...
    def _parse_temporal_dtype_string(cls, string: str) -> ArrowDtype:
...
    def _is_numeric(self) -> bool:
...
    def _is_boolean(self) -> bool:
...
    def _get_common_dtype(self, dtypes: list[DtypeObj]) -> DtypeObj | None:
        # We unwrap any masked dtypes, find the common dtype we would use
        #  for that, then re-mask the result.
        # Mirrors BaseMaskedDtype
...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> ArrowExtensionArray:

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/dtypes/test_common.py
--------------------------------------------------------------------------------
def to_ea_dtypes(dtypes):
...
def to_numpy_dtypes(dtypes):
...
class TestNumpyEADtype:
    # Passing invalid dtype, both as a string or object, must raise TypeError
    # Per issue GH15520
    @pytest.mark.parametrize("box", [pd.Timestamp, "pd.Timestamp", list])
    def test_invalid_dtype_error(self, box):
...
    def test_pandas_dtype_valid(self, dtype):
...
    def test_numpy_dtype(self, dtype):
...
    def test_numpy_string_dtype(self):
        # do not parse freq-like string as period dtype
...
    def test_datetimetz_dtype(self, dtype):
...
    def test_categorical_dtype(self):
...
    def test_period_dtype(self, dtype):
...
def test_dtype_equal(name1, dtype1, name2, dtype2):
    # match equal to self, but not equal to other
...
def test_pyarrow_string_import_error(name, dtype):
    # GH-44276
...
def test_dtype_equal_strict(dtype1, dtype2):
...
def get_is_dtype_funcs():
...
def test_get_dtype_error_catch(func):
    # see gh-15941
    #
    # No exception should be raised.

...
def test_is_object():
...
def test_is_sparse(check_scipy):
...
def test_is_scipy_sparse():
...
def test_is_datetime64_dtype():
...
def test_is_datetime64tz_dtype():
...
def test_custom_ea_kind_M_not_datetime64tz():
    # GH 34986
    class NotTZDtype(ExtensionDtype):
        @property
        def kind(self) -> str:
...
def test_is_timedelta64_dtype():
...
def test_is_period_dtype():
...
def test_is_interval_dtype():
...
def test_is_categorical_dtype():
...
def test_is_string_dtype(dtype, expected):
    # GH#54661

...
def test_is_string_dtype_arraylike_with_object_elements_not_strings(data):
    # GH 15585
...
def test_is_string_dtype_nullable(nullable_string_dtype):
...
def test_is_integer_dtype(dtype):
...
def test_is_not_integer_dtype(dtype):
...
def test_is_signed_integer_dtype(dtype):
...
def test_is_not_signed_integer_dtype(dtype):
...
def test_is_unsigned_integer_dtype(dtype):
...
def test_is_not_unsigned_integer_dtype(dtype):
...
def test_is_int64_dtype(dtype):
...
def test_type_comparison_with_numeric_ea_dtype(any_numeric_ea_dtype):
    # GH#43038
...
def test_type_comparison_with_real_numpy_dtype(any_real_numpy_dtype):
    # GH#43038
...
def test_type_comparison_with_signed_int_ea_dtype_and_signed_int_numpy_dtype(
    any_signed_int_ea_dtype, any_signed_int_numpy_dtype
):
    # GH#43038
...
def test_is_not_int64_dtype(dtype):
...
def test_is_datetime64_any_dtype():
...
def test_is_datetime64_ns_dtype():
...
def test_is_timedelta64_ns_dtype():
...
def test_is_numeric_v_string_like():
...
def test_needs_i8_conversion():
...
def test_is_numeric_dtype():
...
    class MyNumericDType(ExtensionDtype):
        @property
        def type(self):
...
        def name(self):
...
        def construct_array_type(cls):
...
        def _is_numeric(self) -> bool:
...
def test_is_any_real_numeric_dtype():
...
def test_is_float_dtype():
...
def test_is_bool_dtype():
...
def test_is_bool_dtype_numpy_error():
    # GH39010
...
def test_is_extension_array_dtype(check_scipy):
...
def test_is_complex_dtype():
...
def test_get_dtype(input_param, result):
...
def test_get_dtype_fails(input_param, expected_error_message):
    # python objects
    # 2020-02-02 npdev changed error message
...
def test__is_dtype_type(input_param, result):
...
def test_astype_nansafe_copy_false(any_int_numpy_dtype):
    # GH#34457 use astype, not view
...
def test_astype_object_preserves_datetime_na(from_type):
...
def test_validate_allhashable():
...
def test_pandas_dtype_numpy_warning():
    # GH#51523
...
def test_pandas_dtype_ea_not_instance():
    # GH 31356 GH 54592
...
def test_pandas_dtype_string_dtypes(string_storage):
...
    assert result == np.dtype("U")

    with pd.option_context("string_storage", string_storage):
        result = pandas_dtype("string")
    assert result == pd.StringDtype(string_storage, na_value=pd.NA)


@td.skip_if_installed("pyarrow")
def test_construct_from_string_without_pyarrow_installed():
    # GH 57928
    with pytest.raises(ImportError, match="pyarrow>=10.0.1 is required"): #❗UNCOVERED: NEED TEST
        pd.Series([-1.5, 0.2, None], dtype="float32[pyarrow]") #❗UNCOVERED: NEED TEST

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/doc/source/whatsnew/v3.0.0.rst b/doc/source/whatsnew/v3.0.0.rst
index 1b12735f0e7c1..4bd31de185bb4 100644
--- a/doc/source/whatsnew/v3.0.0.rst
+++ b/doc/source/whatsnew/v3.0.0.rst
@@ -761,6 +761,7 @@ ExtensionArray
 - Bug in :meth:`.arrays.ArrowExtensionArray.__setitem__` which caused wrong behavior when using an integer array with repeated values as a key (:issue:`58530`)
 - Bug in :meth:`api.types.is_datetime64_any_dtype` where a custom :class:`ExtensionDtype` would return ``False`` for array-likes (:issue:`57055`)
 - Bug in comparison between object with :class:`ArrowDtype` and incompatible-dtyped (e.g. string vs bool) incorrectly raising instead of returning all-``False`` (for ``==``) or all-``True`` (for ``!=``) (:issue:`59505`)
+- Bug in constructing pandas data structures when passing into ``dtype`` a string of the type followed by ``[pyarrow]`` while PyArrow is not installed would raise ``NameError`` rather than ``ImportError`` (:issue:`57928`)
 - Bug in various :class:`DataFrame` reductions for pyarrow temporal dtypes returning incorrect dtype when result was null (:issue:`59234`)
 
 Styler
diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index 96b0aa16940a6..e5d1033de4457 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -2344,6 +2344,8 @@ def construct_from_string(cls, string: str) -> ArrowDtype:
         if string == "string[pyarrow]":
             # Ensure Registry.find skips ArrowDtype to use StringDtype instead
             raise TypeError("string[pyarrow] should be constructed by StringDtype")
+        if pa_version_under10p1:
+            raise ImportError("pyarrow>=10.0.1 is required for ArrowDtype")
 
         base_type = string[:-9]  # get rid of "[pyarrow]"
         try:
diff --git a/pandas/tests/dtypes/test_common.py b/pandas/tests/dtypes/test_common.py
index e338fb1331734..5a59617ce5bd3 100644
--- a/pandas/tests/dtypes/test_common.py
+++ b/pandas/tests/dtypes/test_common.py
@@ -835,3 +835,10 @@ def test_pandas_dtype_string_dtypes(string_storage):
     with pd.option_context("string_storage", string_storage):
         result = pandas_dtype("string")
     assert result == pd.StringDtype(string_storage, na_value=pd.NA)
+
+
+@td.skip_if_installed("pyarrow")
+def test_construct_from_string_without_pyarrow_installed():
+    # GH 57928
+    with pytest.raises(ImportError, match="pyarrow>=10.0.1 is required"):
+        pd.Series([-1.5, 0.2, None], dtype="float32[pyarrow]")

```
