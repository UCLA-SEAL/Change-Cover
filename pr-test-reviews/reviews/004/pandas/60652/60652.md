## [PR 60652](https://github.com/pandas-dev/pandas/pull/60652)

## PR Summary

This pull request backports a fix from #60637 that raises a proper TypeError for string data types in the interpolate function of pandas. It includes modifications to tests and adjustments for NumPyExtensionArray. The changes have been merged into the pandas 2.3.x branch, contributing to ongoing maintenance and bug fixing.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# pandas/core/arrays/arrow/array.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/core/arrays/numpy_.py
--------------------------------------------------------------------------------
class NumpyExtensionArray(  # type: ignore[misc]
    OpsMixin,
    NDArrayBackedExtensionArray,
    ObjectStringArrayMixin,
):
...
    def __init__(
        self, values: np.ndarray | NumpyExtensionArray, copy: bool = False
    ) -> None:
...
    def _from_sequence(
        cls, scalars, *, dtype: Dtype | None = None, copy: bool = False
    ) -> NumpyExtensionArray:
...
    def dtype(self) -> NumpyEADtype:
...
    def __array__(
        self, dtype: NpDtype | None = None, copy: bool | None = None
    ) -> np.ndarray:
...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs):
        # Lightly modified version of
        # https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html
        # The primary modification is not boxing scalar return values
        # in NumpyExtensionArray, since pandas' ExtensionArrays are 1-d.
...
    def astype(self, dtype, copy: bool = True):
...
    def isna(self) -> np.ndarray:
...
    def _validate_scalar(self, fill_value):
...
    def _values_for_factorize(self) -> tuple[np.ndarray, float | None]:
...
    def _pad_or_backfill(
        self,
        *,
        method: FillnaOptions,
        limit: int | None = None,
        limit_area: Literal["inside", "outside"] | None = None,
        copy: bool = True,
    ) -> Self:
...
    def interpolate(
        self,
        *,
        method: InterpolateOptions,
        axis: int,
        index: Index,
        limit,
        limit_direction,
        limit_area,
        copy: bool,
        **kwargs,
    ) -> Self:
        """
        See NDFrame.interpolate.__doc__.
        """
        # NB: we return type(self) even if copy=False
        if not self.dtype._is_numeric:
            raise TypeError(f"Cannot interpolate with {self.dtype} dtype") #❗UNCOVERED: NEED TEST

        if not copy:
            out_data = self._ndarray
        else:
            out_data = self._ndarray.copy()

        # TODO: assert we have floating dtype?
        missing.interpolate_2d_inplace(
            out_data,
            method=method,
...
    def any(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def all(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def min(
        self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs
    ) -> Scalar:
...
    def max(
        self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs
    ) -> Scalar:
...
    def sum(
        self,
        *,
        axis: AxisInt | None = None,
        skipna: bool = True,
        min_count: int = 0,
        **kwargs,
    ) -> Scalar:
...
    def prod(
        self,
        *,
        axis: AxisInt | None = None,
        skipna: bool = True,
        min_count: int = 0,
        **kwargs,
    ) -> Scalar:
...
    def mean(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def median(
        self,
        *,
        axis: AxisInt | None = None,
        out=None,
        overwrite_input: bool = False,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def std(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def var(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def sem(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        ddof: int = 1,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def kurt(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def skew(
        self,
        *,
        axis: AxisInt | None = None,
        dtype: NpDtype | None = None,
        out=None,
        keepdims: bool = False,
        skipna: bool = True,
    ):
...
    def to_numpy(
        self,
        dtype: npt.DTypeLike | None = None,
        copy: bool = False,
        na_value: object = lib.no_default,
    ) -> np.ndarray:
...
    def __invert__(self) -> NumpyExtensionArray:
...
    def __neg__(self) -> NumpyExtensionArray:
...
    def __pos__(self) -> NumpyExtensionArray:
...
    def __abs__(self) -> NumpyExtensionArray:
...
    def _cmp_method(self, other, op):
...
    def _wrap_ndarray_result(self, result: np.ndarray):
        # If we have timedelta64[ns] result, return a TimedeltaArray instead
        #  of a NumpyExtensionArray

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/extension/test_arrow.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/frame/methods/test_interpolate.py
--------------------------------------------------------------------------------
class TestDataFrameInterpolate:
    def test_interpolate_complex(self):
        # GH#53635
...
    def test_interpolate_datetimelike_values(self, frame_or_series):
        # GH#11312, GH#51005
...
    def test_interpolate_inplace(self, frame_or_series, using_array_manager, request):
        # GH#44749
...
    def test_interp_basic(self, using_copy_on_write, using_infer_string):
...
        )
        expected = DataFrame(
            {
                "A": [1.0, 2.0, 3.0, 4.0],
                "B": [1.0, 4.0, 9.0, 9.0],
                "C": [1, 2, 3, 5],
                "D": list("abcd"),
            }
        )
        if using_infer_string:
            dtype = "str" if using_infer_string else "object" #❗UNCOVERED: NEED TEST
            msg = f"[Cc]annot interpolate with {dtype} dtype" #❗UNCOVERED: NEED TEST
            with pytest.raises(TypeError, match=msg): #❗UNCOVERED: NEED TEST
                df.interpolate() #❗UNCOVERED: NEED TEST
            return #❗UNCOVERED: NEED TEST

        msg = "DataFrame.interpolate with object dtype"
        with tm.assert_produces_warning(FutureWarning, match=msg):
            result = df.interpolate()
        tm.assert_frame_equal(result, expected)

        # check we didn't operate inplace GH#45791
        cvalues = df["C"]._values
        dvalues = df["D"].values
        if using_copy_on_write:
...
    def test_interp_basic_with_non_range_index(self, using_infer_string):
...
    def test_interp_empty(self):
        # https://github.com/pandas-dev/pandas/issues/35598
...
    def test_interp_bad_method(self):
...
    def test_interp_combo(self):
...
    def test_inerpolate_invalid_downcast(self):
        # GH#53103
...
    def test_interp_nan_idx(self):
...
    def test_interp_various(self):
...
    def test_interp_alt_scipy(self):
...
    def test_interp_rowwise(self):
...
    def test_interp_axis_names(self, axis_name, axis_number):
        # GH 29132: test axis names
...
    def test_rowwise_alt(self):
...
    def test_interp_leading_nans(self, check_scipy):
...
    def test_interp_raise_on_only_mixed(self, axis):
...
    def test_interp_raise_on_all_object_dtype(self):
        # GH 22985
...
    def test_interp_inplace(self, using_copy_on_write):
...
    def test_interp_inplace_row(self):
        # GH 10395
...
    def test_interp_ignore_all_good(self):
        # GH
...
    def test_interp_time_inplace_axis(self):
        # GH 9687
...
    def test_interp_string_axis(self, axis_name, axis_number):
        # https://github.com/pandas-dev/pandas/issues/25190
...
    def test_interp_fillna_methods(
        self, request, axis, multiblock, method, using_array_manager
    ):
        # GH 12918
...
    def test_interpolate_empty_df(self):
        # GH#53199
...
    def test_interpolate_ea(self, any_int_ea_dtype):
        # GH#55347
...
    def test_interpolate_ea_float(self, dtype):
        # GH#55347
...
    def test_interpolate_arrow(self, dtype):
        # GH#55347

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/pandas/core/arrays/arrow/array.py b/pandas/core/arrays/arrow/array.py
index 0c1e1d0c63c85..00992ade4f160 100644
--- a/pandas/core/arrays/arrow/array.py
+++ b/pandas/core/arrays/arrow/array.py
@@ -2150,6 +2150,9 @@ def interpolate(
         See NDFrame.interpolate.__doc__.
         """
         # NB: we return type(self) even if copy=False
+        if not self.dtype._is_numeric:
+            raise TypeError(f"Cannot interpolate with {self.dtype} dtype")
+
         mask = self.isna()
         if self.dtype.kind == "f":
             data = self._pa_array.to_numpy()
diff --git a/pandas/core/arrays/numpy_.py b/pandas/core/arrays/numpy_.py
index 9f7238a97d808..07fa6254d87f3 100644
--- a/pandas/core/arrays/numpy_.py
+++ b/pandas/core/arrays/numpy_.py
@@ -287,6 +287,9 @@ def interpolate(
         See NDFrame.interpolate.__doc__.
         """
         # NB: we return type(self) even if copy=False
+        if not self.dtype._is_numeric:
+            raise TypeError(f"Cannot interpolate with {self.dtype} dtype")
+
         if not copy:
             out_data = self._ndarray
         else:
diff --git a/pandas/tests/extension/test_arrow.py b/pandas/tests/extension/test_arrow.py
index 470ca0673c60e..d524ed5a16828 100644
--- a/pandas/tests/extension/test_arrow.py
+++ b/pandas/tests/extension/test_arrow.py
@@ -3350,6 +3350,17 @@ def test_string_to_datetime_parsing_cast():
     tm.assert_series_equal(result, expected)
 
 
+@pytest.mark.skipif(
+    pa_version_under13p0, reason="pairwise_diff_checked not implemented in pyarrow"
+)
+def test_interpolate_not_numeric(data):
+    if not data.dtype._is_numeric:
+        ser = pd.Series(data)
+        msg = re.escape(f"Cannot interpolate with {ser.dtype} dtype")
+        with pytest.raises(TypeError, match=msg):
+            pd.Series(data).interpolate()
+
+
 def test_string_to_time_parsing_cast():
     # GH 56463
     string_times = ["11:41:43.076160"]
diff --git a/pandas/tests/frame/methods/test_interpolate.py b/pandas/tests/frame/methods/test_interpolate.py
index bbb5e59e4a274..ebee19e3de20a 100644
--- a/pandas/tests/frame/methods/test_interpolate.py
+++ b/pandas/tests/frame/methods/test_interpolate.py
@@ -69,11 +69,7 @@ def test_interpolate_inplace(self, frame_or_series, using_array_manager, request
         assert np.shares_memory(orig, obj.values)
         assert orig.squeeze()[1] == 1.5
 
-    # TODO(infer_string) raise proper TypeError in case of string dtype
-    @pytest.mark.xfail(
-        using_string_dtype(), reason="interpolate doesn't work for string"
-    )
-    def test_interp_basic(self, using_copy_on_write):
+    def test_interp_basic(self, using_copy_on_write, using_infer_string):
         df = DataFrame(
             {
                 "A": [1, 2, np.nan, 4],
@@ -90,6 +86,13 @@ def test_interp_basic(self, using_copy_on_write):
                 "D": list("abcd"),
             }
         )
+        if using_infer_string:
+            dtype = "str" if using_infer_string else "object"
+            msg = f"[Cc]annot interpolate with {dtype} dtype"
+            with pytest.raises(TypeError, match=msg):
+                df.interpolate()
+            return
+
         msg = "DataFrame.interpolate with object dtype"
         with tm.assert_produces_warning(FutureWarning, match=msg):
             result = df.interpolate()
@@ -111,8 +114,8 @@ def test_interp_basic(self, using_copy_on_write):
         tm.assert_frame_equal(df, expected)
 
         # check we DID operate inplace
-        assert np.shares_memory(df["C"]._values, cvalues)
-        assert np.shares_memory(df["D"]._values, dvalues)
+        assert tm.shares_memory(df["C"]._values, cvalues)
+        assert tm.shares_memory(df["D"]._values, dvalues)
 
     @pytest.mark.xfail(
         using_string_dtype(), reason="interpolate doesn't work for string"

```
