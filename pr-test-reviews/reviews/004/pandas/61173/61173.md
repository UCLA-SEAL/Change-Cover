## [PR 61173](https://github.com/pandas-dev/pandas/pull/61173)

## PR Summary

This PR fixes a bug in the pandas library that prevented proper alignment of overlapping line and bar plots on the same axes. It resolves issue #61161, ensuring visibility without cropping and enhancing the robustness of mixed plot types. The PR adds relevant tests to validate the functionality and documents the changes in the release notes.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# pandas/plotting/_matplotlib/converter.py
--------------------------------------------------------------------------------
def get_pairs():
...
def register_pandas_matplotlib_converters(func: F) -> F:
...
    def wrapper(*args, **kwargs):
...
def pandas_converters() -> Generator[None]:
...
def register() -> None:
...
def deregister() -> None:
    # Renamed in pandas.plotting.__init__
...
def _to_ordinalf(tm: pydt.time) -> float:
...
def time2num(d):
...
class TimeConverter(munits.ConversionInterface):
    @staticmethod
    def convert(value, unit, axis):
...
    def axisinfo(unit, axis) -> munits.AxisInfo | None:
...
    def default_units(x, axis) -> str:
...
class TimeFormatter(mpl.ticker.Formatter):  # pyright: ignore[reportAttributeAccessIssue]
    def __init__(self, locs) -> None:
...
    def __call__(self, x, pos: int | None = 0) -> str:
...
        return pydt.time(h, m).strftime("%H:%M")


# Period Conversion


class PeriodConverter(mdates.DateConverter):
    @staticmethod
    def convert(values, units, axis):
        if not hasattr(axis, "freq"):
            raise TypeError("Axis must have `freq` set to convert to Periods") #❗UNCOVERED: NEED TEST
        return PeriodConverter.convert_from_freq(values, axis.freq)

    @staticmethod
    def convert_from_freq(values, freq):
        if is_nested_list_like(values):
            values = [PeriodConverter._convert_1d(v, freq) for v in values]
        else:
            values = PeriodConverter._convert_1d(values, freq)
        return values

...
    def _convert_1d(values, freq):
...
            warnings.filterwarnings(
                "ignore", r"PeriodDtype\[B\] is deprecated", category=FutureWarning
            )
            if (
                isinstance(values, valid_types)
                or is_integer(values)
                or is_float(values)
            ):
                return get_datevalue(values, freq)
            elif isinstance(values, PeriodIndex):
                return values.asfreq(freq).asi8 #❗UNCOVERED: NEED TEST
            elif isinstance(values, Index):
                return values.map(lambda x: get_datevalue(x, freq)) #❗UNCOVERED: NEED TEST
            elif lib.infer_dtype(values, skipna=False) == "period":
                # https://github.com/pandas-dev/pandas/issues/24304
                # convert ndarray[period] -> PeriodIndex
                return PeriodIndex(values, freq=freq).asi8
            elif isinstance(values, (list, tuple, np.ndarray, Index)):
                return [get_datevalue(x, freq) for x in values]
        return values


def get_datevalue(date, freq):
...
class DatetimeConverter(mdates.DateConverter):
    @staticmethod
    def convert(values, unit, axis):
        # values might be a 1-d array, or a list-like of arrays.
...
    def _convert_1d(values, unit, axis):
        def try_parse(values):
...
    def axisinfo(unit: tzinfo | None, axis) -> munits.AxisInfo:
...
class PandasAutoDateFormatter(mdates.AutoDateFormatter):
    def __init__(self, locator, tz=None, defaultfmt: str = "%Y-%m-%d") -> None:
...
class PandasAutoDateLocator(mdates.AutoDateLocator):
    def get_locator(self, dmin, dmax):
...
    def _get_unit(self):
...
class MilliSecondLocator(mdates.DateLocator):
...
    def __init__(self, tz) -> None:
...
    def _get_unit(self):
...
    def get_unit_generic(freq):
...
    def __call__(self):
        # if no data have been set, this will tank with a ValueError
...
    def _get_interval(self):
...
    def autoscale(self):
...
def _get_default_annual_spacing(nyears) -> tuple[int, int]:
...
def _period_break(dates: PeriodIndex, period: str) -> npt.NDArray[np.intp]:
...
def _period_break_mask(dates: PeriodIndex, period: str) -> npt.NDArray[np.bool_]:
...
def has_level_label(label_flags: npt.NDArray[np.intp], vmin: float) -> bool:
...
def _get_periods_per_ymd(freq: BaseOffset) -> tuple[int, int, int]:
    # error: "BaseOffset" has no attribute "_period_dtype_code"
...
def _daily_finder(vmin: float, vmax: float, freq: BaseOffset) -> np.ndarray:
    # error: "BaseOffset" has no attribute "_period_dtype_code"
...
    def first_label(label_flags):
...
        def _hour_finder(label_interval: int, force_year_start: bool) -> None:
...
        def _minute_finder(label_interval: int) -> None:
...
        def _second_finder(label_interval: int) -> None:
...
def _monthly_finder(vmin: float, vmax: float, freq: BaseOffset) -> np.ndarray:
...
def _quarterly_finder(vmin: float, vmax: float, freq: BaseOffset) -> np.ndarray:
...
def _annual_finder(vmin: float, vmax: float, freq: BaseOffset) -> np.ndarray:
    # Note: small difference here vs other finders in adding 1 to vmax
...
def get_finder(freq: BaseOffset):
    # error: "BaseOffset" has no attribute "_period_dtype_code"
...
class TimeSeries_DateLocator(mpl.ticker.Locator):  # pyright: ignore[reportAttributeAccessIssue]
...
    def __init__(
        self,
        freq: BaseOffset,
        minor_locator: bool = False,
        dynamic_mode: bool = True,
        base: int = 1,
        quarter: int = 1,
        month: int = 1,
        day: int = 1,
        plot_obj=None,
    ) -> None:
...
    def _get_default_locs(self, vmin, vmax):
...
    def __call__(self):
...
    def autoscale(self):
...
class TimeSeries_DateFormatter(mpl.ticker.Formatter):  # pyright: ignore[reportAttributeAccessIssue]
...
    def __init__(
        self,
        freq: BaseOffset,
        minor_locator: bool = False,
        dynamic_mode: bool = True,
        plot_obj=None,
    ) -> None:
...
    def _set_default_format(self, vmin, vmax):
...
    def set_locs(self, locs) -> None:
...
    def __call__(self, x, pos: int | None = 0) -> str:
...
class TimeSeries_TimedeltaFormatter(mpl.ticker.Formatter):  # pyright: ignore[reportAttributeAccessIssue]
...
    def format_timedelta_ticks(x, pos, n_decimals: int) -> str:
...
    def __call__(self, x, pos: int | None = 0) -> str:

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/plotting/_matplotlib/core.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# pandas/tests/plotting/test_series.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/doc/source/whatsnew/v3.0.0.rst b/doc/source/whatsnew/v3.0.0.rst
index 2d74be6f503a2..b03b2305172a7 100644
--- a/doc/source/whatsnew/v3.0.0.rst
+++ b/doc/source/whatsnew/v3.0.0.rst
@@ -769,6 +769,7 @@ Plotting
 - Bug in :meth:`DataFrame.plot.bar` with ``stacked=True`` where labels on stacked bars with zero-height segments were incorrectly positioned at the base instead of the label position of the previous segment (:issue:`59429`)
 - Bug in :meth:`DataFrame.plot.line` raising ``ValueError`` when set both color and a ``dict`` style (:issue:`59461`)
 - Bug in :meth:`DataFrame.plot` that causes a shift to the right when the frequency multiplier is greater than one. (:issue:`57587`)
+- Bug in :meth:`Series.plot` preventing a line and bar from being aligned on the same plot (:issue:`61161`)
 - Bug in :meth:`Series.plot` preventing a line and scatter plot from being aligned (:issue:`61005`)
 - Bug in :meth:`Series.plot` with ``kind="pie"`` with :class:`ArrowDtype` (:issue:`59192`)
 
diff --git a/pandas/plotting/_matplotlib/converter.py b/pandas/plotting/_matplotlib/converter.py
index 4c00049075d03..774062e0f0412 100644
--- a/pandas/plotting/_matplotlib/converter.py
+++ b/pandas/plotting/_matplotlib/converter.py
@@ -225,16 +225,20 @@ def __call__(self, x, pos: int | None = 0) -> str:
 class PeriodConverter(mdates.DateConverter):
     @staticmethod
     def convert(values, units, axis):
+        if not hasattr(axis, "freq"):
+            raise TypeError("Axis must have `freq` set to convert to Periods")
+        return PeriodConverter.convert_from_freq(values, axis.freq)
+
+    @staticmethod
+    def convert_from_freq(values, freq):
         if is_nested_list_like(values):
-            values = [PeriodConverter._convert_1d(v, units, axis) for v in values]
+            values = [PeriodConverter._convert_1d(v, freq) for v in values]
         else:
-            values = PeriodConverter._convert_1d(values, units, axis)
+            values = PeriodConverter._convert_1d(values, freq)
         return values
 
     @staticmethod
-    def _convert_1d(values, units, axis):
-        if not hasattr(axis, "freq"):
-            raise TypeError("Axis must have `freq` set to convert to Periods")
+    def _convert_1d(values, freq):
         valid_types = (str, datetime, Period, pydt.date, pydt.time, np.datetime64)
         with warnings.catch_warnings():
             warnings.filterwarnings(
@@ -248,17 +252,17 @@ def _convert_1d(values, units, axis):
                 or is_integer(values)
                 or is_float(values)
             ):
-                return get_datevalue(values, axis.freq)
+                return get_datevalue(values, freq)
             elif isinstance(values, PeriodIndex):
-                return values.asfreq(axis.freq).asi8
+                return values.asfreq(freq).asi8
             elif isinstance(values, Index):
-                return values.map(lambda x: get_datevalue(x, axis.freq))
+                return values.map(lambda x: get_datevalue(x, freq))
             elif lib.infer_dtype(values, skipna=False) == "period":
                 # https://github.com/pandas-dev/pandas/issues/24304
                 # convert ndarray[period] -> PeriodIndex
-                return PeriodIndex(values, freq=axis.freq).asi8
+                return PeriodIndex(values, freq=freq).asi8
             elif isinstance(values, (list, tuple, np.ndarray, Index)):
-                return [get_datevalue(x, axis.freq) for x in values]
+                return [get_datevalue(x, freq) for x in values]
         return values
 
 
diff --git a/pandas/plotting/_matplotlib/core.py b/pandas/plotting/_matplotlib/core.py
index 24aa848de1b4c..2cf90a06cdc50 100644
--- a/pandas/plotting/_matplotlib/core.py
+++ b/pandas/plotting/_matplotlib/core.py
@@ -59,7 +59,10 @@
 
 from pandas.io.formats.printing import pprint_thing
 from pandas.plotting._matplotlib import tools
-from pandas.plotting._matplotlib.converter import register_pandas_matplotlib_converters
+from pandas.plotting._matplotlib.converter import (
+    PeriodConverter,
+    register_pandas_matplotlib_converters,
+)
 from pandas.plotting._matplotlib.groupby import reconstruct_data_with_by
 from pandas.plotting._matplotlib.misc import unpack_single_str_list
 from pandas.plotting._matplotlib.style import get_standard_colors
@@ -1858,7 +1861,6 @@ def __init__(
         self.bar_width = width
         self._align = align
         self._position = position
-        self.tick_pos = np.arange(len(data))
 
         if is_list_like(bottom):
             bottom = np.array(bottom)
@@ -1871,6 +1873,16 @@ def __init__(
 
         MPLPlot.__init__(self, data, **kwargs)
 
+        if self._is_ts_plot():
+            self.tick_pos = np.array(
+                PeriodConverter.convert_from_freq(
+                    self._get_xticks(),
+                    data.index.freq,
+                )
+            )
+        else:
+            self.tick_pos = np.arange(len(data))
+
     @cache_readonly
     def ax_pos(self) -> np.ndarray:
         return self.tick_pos - self.tickoffset
@@ -1900,6 +1912,7 @@ def lim_offset(self):
 
     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
     @classmethod
+    @register_pandas_matplotlib_converters
     def _plot(  # type: ignore[override]
         cls,
         ax: Axes,
diff --git a/pandas/tests/plotting/test_series.py b/pandas/tests/plotting/test_series.py
index c3b0219971446..98e70f770896c 100644
--- a/pandas/tests/plotting/test_series.py
+++ b/pandas/tests/plotting/test_series.py
@@ -971,3 +971,27 @@ def test_secondary_y_subplot_axis_labels(self):
         s1.plot(ax=ax2)
         assert len(ax.xaxis.get_minor_ticks()) == 0
         assert len(ax.get_xticklabels()) > 0
+
+    def test_bar_line_plot(self):
+        """
+        Test that bar and line plots with the same x values are superposed
+        and that the x limits are set such that the plots are visible.
+        """
+        # GH61161
+        index = period_range("2023", periods=3, freq="Y")
+        years = set(index.year.astype(str))
+        s = Series([1, 2, 3], index=index)
+        ax = plt.subplot()
+        s.plot(kind="bar", ax=ax)
+        bar_xticks = [
+            label for label in ax.get_xticklabels() if label.get_text() in years
+        ]
+        s.plot(kind="line", ax=ax, color="r")
+        line_xticks = [
+            label for label in ax.get_xticklabels() if label.get_text() in years
+        ]
+        assert len(bar_xticks) == len(index)
+        assert bar_xticks == line_xticks
+        x_limits = ax.get_xlim()
+        assert x_limits[0] <= bar_xticks[0].get_position()[0]
+        assert x_limits[1] >= bar_xticks[-1].get_position()[0]

```
