## [PR 14143](https://github.com/Qiskit/qiskit/pull/14143)

## PR Summary

Pull Request #14143 enhances Qiskit's synthesis capabilities by introducing an HLS plugin for new MCX decompositions. It adds HLS passes for the synthesis methods: synth_mcx_1_clean_kg24, synth_mcx_1_dirty_kg24, synth_mcx_2_clean_kg24, and synth_mcx_2_dirty_kg24, as referenced in issue #13922. The PR consists of 14 commits affecting 4 files and includes updates to documentation and tests to ensure reliability. This contribution has been reviewed and successfully merged into the main branch.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# qiskit/transpiler/passes/synthesis/hls_plugins.py
--------------------------------------------------------------------------------
class DefaultSynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class AGSynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class BMSynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class GreedySynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class LayerSynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class LayerLnnSynthesisClifford(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class DefaultSynthesisLinearFunction(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class KMSSynthesisLinearFunction(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class PMHSynthesisLinearFunction(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class KMSSynthesisPermutation(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class BasicSynthesisPermutation(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class ACGSynthesisPermutation(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class QFTSynthesisFull(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class QFTSynthesisLine(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class TokenSwapperSynthesisPermutation(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesisNDirtyI15(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesisNCleanM15(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesis1CleanB95(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesis2CleanKG24(HighLevelSynthesisPlugin):
...
    """

    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
        """Run synthesis for the given MCX gate."""

        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
            # Unfortunately we occasionally have custom instructions called "mcx"
            # which get wrongly caught by the plugin interface. A simple solution is
            # to return None in this case, since HLS would proceed to examine
            # their definition as it should.
            return None #❗UNCOVERED: NEED TEST

        num_ctrl_qubits = high_level_object.num_ctrl_qubits
        num_clean_ancillas = options.get("num_clean_ancillas", 0)

        if num_clean_ancillas < 2:
            return None

        decomposition = synth_mcx_2_clean_kg24(num_ctrl_qubits)
        return decomposition

...
class MCXSynthesis2DirtyKG24(HighLevelSynthesisPlugin):
...
    """

    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
        """Run synthesis for the given MCX gate."""

        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
            # Unfortunately we occasionally have custom instructions called "mcx"
            # which get wrongly caught by the plugin interface. A simple solution is
            # to return None in this case, since HLS would proceed to examine
            # their definition as it should.
            return None #❗UNCOVERED: NEED TEST

        num_ctrl_qubits = high_level_object.num_ctrl_qubits
        num_dirty_ancillas = options.get("num_dirty_ancillas", 0)

        if num_dirty_ancillas < 2:
            return None

        decomposition = synth_mcx_2_dirty_kg24(num_ctrl_qubits)
        return decomposition

...
class MCXSynthesis1CleanKG24(HighLevelSynthesisPlugin):
...
    """

    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
        """Run synthesis for the given MCX gate."""

        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
            # Unfortunately we occasionally have custom instructions called "mcx"
            # which get wrongly caught by the plugin interface. A simple solution is
            # to return None in this case, since HLS would proceed to examine
            # their definition as it should.
            return None #❗UNCOVERED: NEED TEST

        num_ctrl_qubits = high_level_object.num_ctrl_qubits
        num_clean_ancillas = options.get("num_clean_ancillas", 0)

        if num_clean_ancillas < 1:
            return None

        decomposition = synth_mcx_1_clean_kg24(num_ctrl_qubits)
        return decomposition

...
class MCXSynthesis1DirtyKG24(HighLevelSynthesisPlugin):
...
    """

    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
        """Run synthesis for the given MCX gate."""

        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
            # Unfortunately we occasionally have custom instructions called "mcx"
            # which get wrongly caught by the plugin interface. A simple solution is
            # to return None in this case, since HLS would proceed to examine
            # their definition as it should.
            return None #❗UNCOVERED: NEED TEST

        num_ctrl_qubits = high_level_object.num_ctrl_qubits
        num_dirty_ancillas = options.get("num_dirty_ancillas", 0)

        if num_dirty_ancillas < 1:
            return None

        decomposition = synth_mcx_1_dirty_kg24(num_ctrl_qubits)
        return decomposition

...
class MCXSynthesisGrayCode(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesisNoAuxV24(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCXSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCMTSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
        # first try to use the V-chain synthesis if enough auxiliary qubits are available
...
class MCMTSynthesisNoAux(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MCMTSynthesisVChain(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class IntComparatorSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class IntComparatorSynthesisNoAux(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class IntComparatorSynthesis2s(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class ModularAdderSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class ModularAdderSynthesisC04(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class ModularAdderSynthesisV95(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class ModularAdderSynthesisD00(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class HalfAdderSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class HalfAdderSynthesisC04(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class HalfAdderSynthesisV95(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class HalfAdderSynthesisD00(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class FullAdderSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class FullAdderSynthesisC04(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class FullAdderSynthesisV95(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MultiplierSynthesisH18(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class MultiplierSynthesisR17(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class PauliEvolutionSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class PauliEvolutionSynthesisRustiq(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
class AnnotatedSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
...
    def _apply_annotations(circuit: QuantumCircuit, modifiers: list[Modifier]) -> QuantumCircuit:
...
    def _instruction_to_circuit(op: Operation) -> QuantumCircuit:
...
class WeightedSumSynthesisDefault(HighLevelSynthesisPlugin):
...
    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/pyproject.toml b/pyproject.toml
index 86c505a72db0..50539937f110 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -86,6 +86,10 @@ sk = "qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis:SolovayKitaevS
 "linear_function.pmh" = "qiskit.transpiler.passes.synthesis.hls_plugins:PMHSynthesisLinearFunction"
 "mcx.n_dirty_i15" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesisNDirtyI15"
 "mcx.n_clean_m15" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesisNCleanM15"
+"mcx.2_clean_kg24" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesis2CleanKG24"
+"mcx.2_dirty_kg24" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesis2DirtyKG24"
+"mcx.1_clean_kg24" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesis1CleanKG24"
+"mcx.1_dirty_kg24" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesis1DirtyKG24"
 "mcx.1_clean_b95" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesis1CleanB95"
 "mcx.gray_code" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesisGrayCode"
 "mcx.noaux_v24" = "qiskit.transpiler.passes.synthesis.hls_plugins:MCXSynthesisNoAuxV24"
diff --git a/qiskit/transpiler/passes/synthesis/hls_plugins.py b/qiskit/transpiler/passes/synthesis/hls_plugins.py
index 471b34304c48..7d97d3475038 100644
--- a/qiskit/transpiler/passes/synthesis/hls_plugins.py
+++ b/qiskit/transpiler/passes/synthesis/hls_plugins.py
@@ -194,6 +194,26 @@
       - `0`
       - `k-2`
       - at most `8*k-6` CX gates
+    * - ``"2_clean_kg24"``
+      - :class:`~.MCXSynthesis2CleanKG24`
+      - `2`
+      - `0`
+      - at most `12*k-18` CX gates
+    * - ``"2_dirty_kg24"``
+      - :class:`~.MCXSynthesis2DirtyKG24`
+      - `0`
+      - `2`
+      - at most `24*k-48` CX gates
+    * - ``"1_clean_kg24"``
+      - :class:`~.MCXSynthesis1CleanKG24`
+      - `1`
+      - `0`
+      - at most `12*k-18` CX gates
+    * - ``"1_dirty_kg24"``
+      - :class:`~.MCXSynthesis1DirtyKG24`
+      - `0`
+      - `1`
+      - at most `24*k-48` CX gates
     * - ``"1_clean_b95"``
       - :class:`~.MCXSynthesis1CleanB95`
       - `1`
@@ -212,6 +232,10 @@
    MCXSynthesisNoAuxV24
    MCXSynthesisNCleanM15
    MCXSynthesisNDirtyI15
+   MCXSynthesis2CleanKG24
+   MCXSynthesis2DirtyKG24
+   MCXSynthesis1CleanKG24
+   MCXSynthesis1DirtyKG24
    MCXSynthesis1CleanB95
    MCXSynthesisDefault
 
@@ -521,7 +545,11 @@
 )
 from qiskit.synthesis.multi_controlled import (
     synth_mcx_n_dirty_i15,
+    synth_mcx_2_dirty_kg24,
+    synth_mcx_1_dirty_kg24,
     synth_mcx_n_clean_m15,
+    synth_mcx_2_clean_kg24,
+    synth_mcx_1_clean_kg24,
     synth_mcx_1_clean_b95,
     synth_mcx_gray_code,
     synth_mcx_noaux_v24,
@@ -1143,6 +1171,174 @@ def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **
         return decomposition
 
 
+class MCXSynthesis2CleanKG24(HighLevelSynthesisPlugin):
+    r"""Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and
+    Gidney (2024).
+
+    See [1] for details.
+
+    The plugin name is :``mcx.2_clean_kg24`` which can be used as the key on an :class:`~.HLSConfig`
+    object to use this method with :class:`~.HighLevelSynthesis`.
+
+    For a multi-controlled X gate with :math:`k\ge 3` control qubits this synthesis method requires
+    :math:`2` additional clean ancillary qubits. The synthesized circuit consists of :math:`k + 2`
+    qubits and at most :math:`12 * k - 18` CX gates.
+
+    The plugin supports the following plugin-specific options:
+
+    * num_clean_ancillas: The number of clean ancillary qubits available.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
+        """Run synthesis for the given MCX gate."""
+
+        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
+            # Unfortunately we occasionally have custom instructions called "mcx"
+            # which get wrongly caught by the plugin interface. A simple solution is
+            # to return None in this case, since HLS would proceed to examine
+            # their definition as it should.
+            return None
+
+        num_ctrl_qubits = high_level_object.num_ctrl_qubits
+        num_clean_ancillas = options.get("num_clean_ancillas", 0)
+
+        if num_clean_ancillas < 2:
+            return None
+
+        decomposition = synth_mcx_2_clean_kg24(num_ctrl_qubits)
+        return decomposition
+
+
+class MCXSynthesis2DirtyKG24(HighLevelSynthesisPlugin):
+    r"""Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and
+    Gidney (2024).
+
+    See [1] for details.
+
+    The plugin name is :``mcx.2_dirty_kg24`` which can be used as the key on an :class:`~.HLSConfig`
+    object to use this method with :class:`~.HighLevelSynthesis`.
+
+    For a multi-controlled X gate with :math:`k\ge 3` control qubits this synthesis method requires
+    :math:`2` additional dirty ancillary qubits. The synthesized circuit consists of :math:`k + 2`
+    qubits and at most :math:`24 * k - 48` CX gates.
+
+    The plugin supports the following plugin-specific options:
+
+    * num_clean_ancillas: The number of clean ancillary qubits available.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
+        """Run synthesis for the given MCX gate."""
+
+        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
+            # Unfortunately we occasionally have custom instructions called "mcx"
+            # which get wrongly caught by the plugin interface. A simple solution is
+            # to return None in this case, since HLS would proceed to examine
+            # their definition as it should.
+            return None
+
+        num_ctrl_qubits = high_level_object.num_ctrl_qubits
+        num_dirty_ancillas = options.get("num_dirty_ancillas", 0)
+
+        if num_dirty_ancillas < 2:
+            return None
+
+        decomposition = synth_mcx_2_dirty_kg24(num_ctrl_qubits)
+        return decomposition
+
+
+class MCXSynthesis1CleanKG24(HighLevelSynthesisPlugin):
+    r"""Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and
+    Gidney (2024).
+
+    See [1] for details.
+
+    The plugin name is :``mcx.1_clean_kg24`` which can be used as the key on an :class:`~.HLSConfig`
+    object to use this method with :class:`~.HighLevelSynthesis`.
+
+    For a multi-controlled X gate with :math:`k\ge 3` control qubits this synthesis method requires
+    :math:`1` additional clean ancillary qubit. The synthesized circuit consists of :math:`k + 2`
+    qubits and at most :math:`12 * k - 18` CX gates.
+
+    The plugin supports the following plugin-specific options:
+
+    * num_clean_ancillas: The number of clean ancillary qubits available.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
+        """Run synthesis for the given MCX gate."""
+
+        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
+            # Unfortunately we occasionally have custom instructions called "mcx"
+            # which get wrongly caught by the plugin interface. A simple solution is
+            # to return None in this case, since HLS would proceed to examine
+            # their definition as it should.
+            return None
+
+        num_ctrl_qubits = high_level_object.num_ctrl_qubits
+        num_clean_ancillas = options.get("num_clean_ancillas", 0)
+
+        if num_clean_ancillas < 1:
+            return None
+
+        decomposition = synth_mcx_1_clean_kg24(num_ctrl_qubits)
+        return decomposition
+
+
+class MCXSynthesis1DirtyKG24(HighLevelSynthesisPlugin):
+    r"""Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and
+    Gidney (2024).
+
+    See [1] for details.
+
+    The plugin name is :``mcx.1_dirty_kg24`` which can be used as the key on an :class:`~.HLSConfig`
+    object to use this method with :class:`~.HighLevelSynthesis`.
+
+    For a multi-controlled X gate with :math:`k\ge 3` control qubits this synthesis method requires
+    :math:`1` additional dirty ancillary qubit. The synthesized circuit consists of :math:`k + 2`
+    qubits and at most :math:`24 * k - 48` CX gates.
+
+    The plugin supports the following plugin-specific options:
+
+    * num_clean_ancillas: The number of clean ancillary qubits available.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **options):
+        """Run synthesis for the given MCX gate."""
+
+        if not isinstance(high_level_object, (MCXGate, C3XGate, C4XGate)):
+            # Unfortunately we occasionally have custom instructions called "mcx"
+            # which get wrongly caught by the plugin interface. A simple solution is
+            # to return None in this case, since HLS would proceed to examine
+            # their definition as it should.
+            return None
+
+        num_ctrl_qubits = high_level_object.num_ctrl_qubits
+        num_dirty_ancillas = options.get("num_dirty_ancillas", 0)
+
+        if num_dirty_ancillas < 1:
+            return None
+
+        decomposition = synth_mcx_1_dirty_kg24(num_ctrl_qubits)
+        return decomposition
+
+
 class MCXSynthesisGrayCode(HighLevelSynthesisPlugin):
     r"""Synthesis plugin for a multi-controlled X gate based on the Gray code.
 
@@ -1226,27 +1422,23 @@ def run(self, high_level_object, coupling_map=None, target=None, qubits=None, **
 
         # Iteratively run other synthesis methods available
 
-        if (
-            decomposition := MCXSynthesisNCleanM15().run(
-                high_level_object, coupling_map, target, qubits, **options
-            )
-        ) is not None:
-            return decomposition
-
-        if (
-            decomposition := MCXSynthesisNDirtyI15().run(
-                high_level_object, coupling_map, target, qubits, **options
-            )
-        ) is not None:
-            return decomposition
-
-        if (
-            decomposition := MCXSynthesis1CleanB95().run(
-                high_level_object, coupling_map, target, qubits, **options
-            )
-        ) is not None:
-            return decomposition
+        for synthesis_method in [
+            MCXSynthesisNCleanM15,
+            MCXSynthesisNDirtyI15,
+            MCXSynthesis2CleanKG24,
+            MCXSynthesis2DirtyKG24,
+            MCXSynthesis1CleanKG24,
+            MCXSynthesis1DirtyKG24,
+            MCXSynthesis1CleanB95,
+        ]:
+            if (
+                decomposition := synthesis_method().run(
+                    high_level_object, coupling_map, target, qubits, **options
+                )
+            ) is not None:
+                return decomposition
 
+        # If no synthesis method was successful, fall back to the default
         return MCXSynthesisNoAuxV24().run(
             high_level_object, coupling_map, target, qubits, **options
         )
diff --git a/releasenotes/notes/add-new-mcx-plugins-2177db9195e2b680.yaml b/releasenotes/notes/add-new-mcx-plugins-2177db9195e2b680.yaml
new file mode 100644
index 000000000000..ac5cccac897b
--- /dev/null
+++ b/releasenotes/notes/add-new-mcx-plugins-2177db9195e2b680.yaml
@@ -0,0 +1,13 @@
+---
+features_transpiler:
+  - |
+    Added multiple high-level-synthesis plugins for synthesizing an :class:`.MCXGate`:
+
+    * :class:`.MCXSynthesis1CleanKG24`, based on :func:`.synth_mcx_1_clean_kg24`.
+    * :class:`.MCXSynthesis1DirtyKG24`, based on :func:`.synth_mcx_1_dirty_kg24`.
+    * :class:`.MCXSynthesis2CleanKG24`, based on :func:`.synth_mcx_2_clean_kg24`.
+    * :class:`.MCXSynthesis2DirtyKG24`, based on :func:`.synth_mcx_2_dirty_kg24`.
+
+    The :class:`.MCXSynthesisDefault` has also been updated to follow the following sequence of
+    MCX synthesizers: "mcx.n_clean_m15", "mcx.n_dirty_i15", "mcx.2_clean_kg24", "mcx.2_dirty_kg24",
+    "mcx.1_clean_kg24", "mcx.1_dirty_kg24" "mcx.1_clean_b95", "mcx.noaux_v24".
diff --git a/test/python/transpiler/test_high_level_synthesis.py b/test/python/transpiler/test_high_level_synthesis.py
index cfc80feb2252..2c07c3ce0def 100644
--- a/test/python/transpiler/test_high_level_synthesis.py
+++ b/test/python/transpiler/test_high_level_synthesis.py
@@ -68,6 +68,10 @@
     MCXSynthesis1CleanB95,
     MCXSynthesisNCleanM15,
     MCXSynthesisNDirtyI15,
+    MCXSynthesis2CleanKG24,
+    MCXSynthesis2DirtyKG24,
+    MCXSynthesis1CleanKG24,
+    MCXSynthesis1DirtyKG24,
     MCXSynthesisGrayCode,
     MCXSynthesisDefault,
     MCXSynthesisNoAuxV24,
@@ -2559,6 +2563,69 @@ def test_mcx_plugins_applicability(self):
             )
             self.assertIsNone(decomposition)
 
+        with self.subTest(method="2_clean_kg24", num_clean_ancillas=2, num_dirty_ancillas=0):
+            # should have a decomposition
+            decomposition = MCXSynthesis2CleanKG24().run(
+                gate, num_clean_ancillas=2, num_dirty_ancillas=0
+            )
+            self.assertIsNotNone(decomposition)
+
+        with self.subTest(method="2_clean_kg24", num_clean_ancillas=1, num_dirty_ancillas=0):
+            # should not have a decomposition
+            decomposition = MCXSynthesis2CleanKG24().run(
+                gate, num_clean_ancillas=1, num_dirty_ancillas=0
+            )
+            self.assertIsNone(decomposition)
+            decomposition = MCXSynthesis2CleanKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=0
+            )
+            self.assertIsNone(decomposition)
+
+        with self.subTest(method="2_dirty_kg24", num_clean_ancillas=0, num_dirty_ancillas=2):
+            # should have a decomposition
+            decomposition = MCXSynthesis2DirtyKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=2
+            )
+            self.assertIsNotNone(decomposition)
+
+        with self.subTest(method="2_dirty_kg24", num_clean_ancillas=0, num_dirty_ancillas=1):
+            # should not have a decomposition
+            decomposition = MCXSynthesis2DirtyKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=1
+            )
+            self.assertIsNone(decomposition)
+            decomposition = MCXSynthesis2DirtyKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=0
+            )
+            self.assertIsNone(decomposition)
+
+        with self.subTest(method="1_clean_kg24", num_clean_ancillas=1, num_dirty_ancillas=0):
+            # should have a decomposition
+            decomposition = MCXSynthesis1CleanKG24().run(
+                gate, num_clean_ancillas=1, num_dirty_ancillas=0
+            )
+            self.assertIsNotNone(decomposition)
+
+        with self.subTest(method="1_clean_kg24", num_clean_ancillas=0, num_dirty_ancillas=1):
+            # should not have a decomposition
+            decomposition = MCXSynthesis1CleanKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=1
+            )
+            self.assertIsNone(decomposition)
+
+        with self.subTest(method="1_dirty_kg24", num_clean_ancillas=0, num_dirty_ancillas=1):
+            # should have a decomposition
+            decomposition = MCXSynthesis1DirtyKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=1
+            )
+            self.assertIsNotNone(decomposition)
+        with self.subTest(method="1_dirty_kg24", num_clean_ancillas=0, num_dirty_ancillas=0):
+            # should not have a decomposition
+            decomposition = MCXSynthesis1DirtyKG24().run(
+                gate, num_clean_ancillas=0, num_dirty_ancillas=0
+            )
+            self.assertIsNone(decomposition)
+
         with self.subTest(method="1_clean_b95", num_clean_ancillas=1, num_dirty_ancillas=0):
             # should have a decomposition
             decomposition = MCXSynthesis1CleanB95().run(
@@ -2615,7 +2682,18 @@ def test_mcx_plugins_applicability(self):
             )
             self.assertIsNotNone(decomposition)
 
-    @data("n_clean_m15", "n_dirty_i15", "1_clean_b95", "noaux_v24", "gray_code", "default")
+    @data(
+        "n_clean_m15",
+        "n_dirty_i15",
+        "2_clean_kg24",
+        "2_dirty_kg24",
+        "1_clean_kg24",
+        "1_dirty_kg24",
+        "1_clean_b95",
+        "noaux_v24",
+        "gray_code",
+        "default",
+    )
     def test_mcx_plugins_correctness_from_arbitrary(self, mcx_plugin_name):
         """Test that all plugins return a correct Operator when qubits are not
         initially zero."""
@@ -2630,7 +2708,18 @@ def test_mcx_plugins_correctness_from_arbitrary(self, mcx_plugin_name):
         qct = hls_pass(qc)
         self.assertEqual(Operator(qc), Operator(qct))
 
-    @data("n_clean_m15", "n_dirty_i15", "1_clean_b95", "noaux_v24", "gray_code", "default")
+    @data(
+        "n_clean_m15",
+        "n_dirty_i15",
+        "2_clean_kg24",
+        "2_dirty_kg24",
+        "1_clean_kg24",
+        "1_dirty_kg24",
+        "1_clean_b95",
+        "noaux_v24",
+        "gray_code",
+        "default",
+    )
     def test_mcx_plugins_correctness_from_zero(self, mcx_plugin_name):
         """Test that all plugins return a correct Statevector when qubits are
         initially zero."""

```
