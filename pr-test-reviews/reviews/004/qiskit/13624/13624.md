## [PR 13624](https://github.com/Qiskit/qiskit/pull/13624)

## PR Summary

This pull request (PR #13624) fixes a bug in the `PauliList.insert(..., qubit=True)` method for length-1 `pauli_list`, which incorrectly set the phase attribute as a 2D array instead of 1D. The change simplifies phase broadcasting by removing a problematic line of code, allowing NumPy to handle the broadcasting correctly. It also adds a validation check in `PauliList.from_symplectic(...)` to reject multi-dimensional phase inputs and includes a test for issue #13623.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# qiskit/quantum_info/operators/symplectic/pauli_list.py
--------------------------------------------------------------------------------
class PauliList(BasePauli, LinearMixin, GroupMixin):
...
    def __init__(self, data: Pauli | list):
...
    def settings(self):
...
    def __array__(self, dtype=None, copy=None):
...
    def _from_paulis(data):
...
    def __repr__(self):
...
    def __str__(self):
...
    def _truncated_str(self, show_class):
...
    def __eq__(self, other):
...
    def equiv(self, other: PauliList | Pauli) -> np.ndarray:
...
    def phase(self):
...
    def phase(self, value):
        # Convert group phase convetion to internal ZX-phase convention
...
    def x(self):
...
    def x(self, val):
...
    def z(self):
...
    def z(self, val):
...
    def shape(self):
...
    def size(self):
...
    def __len__(self):
...
    def __getitem__(self, index):
...
    def __setitem__(self, index, value):
...
    def delete(self, ind: int | list, qubit: bool = False) -> PauliList:
...
    def insert(self, ind: int, value: PauliList, qubit: bool = False) -> PauliList:
...
    def argsort(self, weight: bool = False, phase: bool = False) -> np.ndarray:
...
    def sort(self, weight: bool = False, phase: bool = False) -> PauliList:
...
    def unique(self, return_index: bool = False, return_counts: bool = False) -> PauliList:
...
    def tensor(self, other: PauliList) -> PauliList:
...
    def expand(self, other: PauliList) -> PauliList:
...
    def compose(
        self,
        other: PauliList,
        qargs: None | list = None,
        front: bool = False,
        inplace: bool = False,
    ) -> PauliList:
...
    def dot(self, other: PauliList, qargs: None | list = None, inplace: bool = False) -> PauliList:
...
    def _add(self, other, qargs=None):
...
    def _multiply(self, other):
...
    def conjugate(self):
...
    def transpose(self):
...
    def adjoint(self):
...
    def inverse(self):
...
    def commutes(self, other: BasePauli, qargs: list | None = None) -> bool:
...
    def anticommutes(self, other: BasePauli, qargs: list | None = None) -> bool:
...
    def commutes_with_all(self, other: PauliList) -> np.ndarray:
...
    def anticommutes_with_all(self, other: PauliList) -> np.ndarray:
...
    def _commutes_with_all(self, other, anti=False):
...
    def evolve(
        self,
        other: Pauli | Clifford | QuantumCircuit,
        qargs: list | None = None,
        frame: Literal["h", "s"] = "h",
    ) -> Pauli:
...
    def to_labels(self, array: bool = False):
...
    def to_matrix(self, sparse: bool = False, array: bool = False) -> list:
...
    def label_iter(self):
...
        class LabelIterator(CustomIterator):
...
            def __repr__(self):
...
            def __getitem__(self, key):
...
    def matrix_iter(self, sparse: bool = False):
...
        class MatrixIterator(CustomIterator):
...
            def __repr__(self):
...
            def __getitem__(self, key):
...
    def from_symplectic(
        cls, z: np.ndarray, x: np.ndarray, phase: np.ndarray | None = 0
    ) -> PauliList:
...

        Args:
            z (np.ndarray): 2D boolean Numpy array.
            x (np.ndarray): 2D boolean Numpy array.
            phase (np.ndarray or None): Optional, 1D integer array from Z_4.

        Returns:
            PauliList: the constructed PauliList.
        """
        if isinstance(phase, np.ndarray) and np.ndim(phase) > 1:
            raise ValueError(f"phase should be at most 1D but has {np.ndim(phase)} dimensions.") #â—UNCOVERED: NEED TEST
        base_z, base_x, base_phase = cls._from_array(z, x, phase)
        return cls(BasePauli(base_z, base_x, base_phase))

    def _noncommutation_graph(self, qubit_wise):
        """Create an edge list representing the non-commutation graph (Pauli Graph).

        An edge (i, j) is present if i and j are not commutable.

        Args:
            qubit_wise (bool): whether the commutation rule is applied to the whole operator,
...
    def noncommutation_graph(self, qubit_wise: bool) -> rx.PyGraph:
...
    def _commuting_groups(self, qubit_wise: bool) -> dict[int, list[int]]:
...
    def group_qubit_wise_commuting(self) -> list[PauliList]:
...
    def group_commuting(self, qubit_wise: bool = False) -> list[PauliList]:

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/qiskit/quantum_info/operators/symplectic/pauli_list.py b/qiskit/quantum_info/operators/symplectic/pauli_list.py
index af2a0ed9407f..8e23b6f31a87 100644
--- a/qiskit/quantum_info/operators/symplectic/pauli_list.py
+++ b/qiskit/quantum_info/operators/symplectic/pauli_list.py
@@ -451,16 +451,14 @@ def insert(self, ind: int, value: PauliList, qubit: bool = False) -> PauliList:
                 f"Index {ind} is greater than number of qubits"
                 f" in the PauliList ({self.num_qubits})"
             )
-        if len(value) == 1:
-            # Pad blocks to correct size
-            value_x = np.vstack(size * [value.x])
-            value_z = np.vstack(size * [value.z])
-            value_phase = np.vstack(size * [value.phase])
-        elif len(value) == size:
+        if len(value) == size:
             #  Blocks are already correct size
             value_x = value.x
             value_z = value.z
-            value_phase = value.phase
+        elif len(value) == 1:
+            # Pad blocks to correct size
+            value_x = np.vstack(size * [value.x])
+            value_z = np.vstack(size * [value.z])
         else:
             # Blocks are incorrect size
             raise QiskitError(
@@ -471,7 +469,7 @@ def insert(self, ind: int, value: PauliList, qubit: bool = False) -> PauliList:
         # Build new array by blocks
         z = np.hstack([self.z[:, :ind], value_z, self.z[:, ind:]])
         x = np.hstack([self.x[:, :ind], value_x, self.x[:, ind:]])
-        phase = self.phase + value_phase
+        phase = self.phase + value.phase
 
         return PauliList.from_symplectic(z, x, phase)
 
@@ -1131,6 +1129,8 @@ def from_symplectic(
         Returns:
             PauliList: the constructed PauliList.
         """
+        if isinstance(phase, np.ndarray) and np.ndim(phase) > 1:
+            raise ValueError(f"phase should be at most 1D but has {np.ndim(phase)} dimensions.")
         base_z, base_x, base_phase = cls._from_array(z, x, phase)
         return cls(BasePauli(base_z, base_x, base_phase))
 
diff --git a/releasenotes/notes/fix-paulilist-length1-phase-688d0e3a64ec9a9f.yaml b/releasenotes/notes/fix-paulilist-length1-phase-688d0e3a64ec9a9f.yaml
new file mode 100644
index 000000000000..a1a59708003c
--- /dev/null
+++ b/releasenotes/notes/fix-paulilist-length1-phase-688d0e3a64ec9a9f.yaml
@@ -0,0 +1,6 @@
+---
+fixes:
+  - |
+    Fixed a bug that caused :meth:`.PauliList.insert` with ``qubit=True`` to produce a `phase`
+    attribute with the wrong shape when the original object was length 1.
+    Fixed `#13623 <https://github.com/Qiskit/qiskit/issues/13623>`__.
diff --git a/test/python/quantum_info/operators/symplectic/test_pauli_list.py b/test/python/quantum_info/operators/symplectic/test_pauli_list.py
index 8c96f63c4ddf..9abc473dc333 100644
--- a/test/python/quantum_info/operators/symplectic/test_pauli_list.py
+++ b/test/python/quantum_info/operators/symplectic/test_pauli_list.py
@@ -1560,6 +1560,15 @@ def test_insert(self):
                 value1 = pauli.insert(1, insert)
                 self.assertEqual(value1, target1)
 
+        # Insert single column to length-1 PauliList:
+        with self.subTest(msg="length-1, single-column, single-val"):
+            pauli = PauliList(["X"])
+            insert = PauliList(["Y"])
+            target0 = PauliList(["YX"])
+            value0 = pauli.insert(1, insert, qubit=True)
+            self.assertEqual(value0, target0)
+            self.assertEqual(value0.phase.shape, (1,))
+
         # Insert single column
         pauli = PauliList(["X", "Y", "Z", "-iI"])
         for i in ["I", "X", "Y", "Z", "iY"]:

```
