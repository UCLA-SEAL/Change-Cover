## [PR 13922](https://github.com/Qiskit/qiskit/pull/13922)

## PR Summary

This PR (#13922) enhances the MCX decomposition capabilities in Qiskit by introducing four new synthesis functions: `synth_mcx_1_clean_kg24`, `synth_mcx_1_dirty_kg24`, `synth_mcx_2_clean_kg24`, and `synth_mcx_2_dirty_kg24`. These functions leverage logarithmic Toffoli depth to improve circuit efficiency by reducing the number of CX gates required. The changes include the addition of new test cases to validate the correctness of these functions. This contribution addresses issue #13913 and marks a significant advancement in Qiskit's synthesis features.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# qiskit/synthesis/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# qiskit/synthesis/multi_controlled/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# qiskit/synthesis/multi_controlled/mcx_synthesis.py
--------------------------------------------------------------------------------
def synth_mcx_n_dirty_i15(
    num_ctrl_qubits: int,
    relative_phase: bool = False,
    action_only: bool = False,
) -> QuantumCircuit:
...
def synth_mcx_n_clean_m15(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_mcx_1_clean_b95(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_mcx_gray_code(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_mcx_noaux_v24(num_ctrl_qubits: int) -> QuantumCircuit:
...
def _linear_depth_ladder_ops(num_ladder_qubits: int) -> tuple[QuantumCircuit, list[int]]:
...

    Raises:
        QiskitError: If num_ladder_qubits <= 2.

    References:
        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
    """

    if num_ladder_qubits <= 2:
        raise QiskitError("n_ctrls >= 3 to use MCX ladder. Otherwise, use CCX") #❗UNCOVERED: NEED TEST

    n = num_ladder_qubits + 1
    qc = QuantumCircuit(n)
    qreg = list(range(n))

    # up-ladder
    for i in range(2, n - 2, 2):
        qc.ccx(qreg[i + 1], qreg[i + 2], qreg[i])
        qc.x(qreg[i])

...
def synth_mcx_1_kg24(num_ctrl_qubits: int, clean: bool = True) -> QuantumCircuit:
...

    Raises:
        QiskitError: If num_ctrl_qubits <= 2.

    References:
        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
    """

    if num_ctrl_qubits <= 2:
        raise QiskitError("kg24 synthesis requires at least 3 control qubits. Use CCX directly.") #❗UNCOVERED: NEED TEST

    q_controls = QuantumRegister(num_ctrl_qubits, name="ctrl")
    q_target = QuantumRegister(1, name="targ")
    q_ancilla = AncillaRegister(1, name="anc")
    qc = QuantumCircuit(q_controls, q_target, q_ancilla, name="mcx_linear_depth")

    ladder_ops, final_ctrl = _linear_depth_ladder_ops(num_ctrl_qubits)
    qc.ccx(q_controls[0], q_controls[1], q_ancilla)  #                  # create cond. clean ancilla
    qc.compose(ladder_ops, q_ancilla[:] + q_controls[:], inplace=True)  # up-ladder
    qc.ccx(q_ancilla, q_controls[final_ctrl], q_target)  #              # target
...
def synth_mcx_1_clean_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_mcx_1_dirty_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
...
def _n_parallel_ccx_x(n: int) -> QuantumCircuit:
...
def _build_logn_depth_ccx_ladder(
    ancilla_idx: int, ctrls: list[int], skip_cond_clean: bool = False
) -> tuple[QuantumCircuit, list[int]]:
...
        new_anc = []
        while len(nxt_batch) > 1:
            ccx_n = len(nxt_batch) // 2
            st = int(len(nxt_batch) % 2)
            ccx_x, ccx_y, ccx_t = (
                nxt_batch[st : st + ccx_n],
                nxt_batch[st + ccx_n :],
                anc[-ccx_n:],
            )
            if not len(ccx_x) == len(ccx_y) == ccx_n >= 1:
                raise QiskitError( #❗UNCOVERED: NEED TEST
                    f"Invalid CCX gate parameters: {len(ccx_x)=} != {len(ccx_y)=} != {len(ccx_n)=}" #❗UNCOVERED: NEED TEST
                ) #❗UNCOVERED: NEED TEST
            if ccx_t != [ancilla_idx]:
                qc.compose(_n_parallel_ccx_x(ccx_n), ccx_x + ccx_y + ccx_t, inplace=True)
            else:
                if not skip_cond_clean:
                    qc.ccx(ccx_x[0], ccx_y[0], ccx_t[0])  #  # create conditionally clean ancilla
            new_anc += nxt_batch[st:]  #                     # newly created cond. clean ancilla
            nxt_batch = ccx_t + nxt_batch[:st]
            anc = anc[:-ccx_n]

        anc = sorted(anc + new_anc)
...
def synth_mcx_2_kg24(num_ctrl_qubits: int, clean: bool = True) -> QuantumCircuit:
...

    Raises:
        QiskitError: If num_ctrl_qubits <= 2.

    References:
        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
    """

    if num_ctrl_qubits <= 2:
        raise QiskitError("kg24 synthesis requires at least 3 control qubits. Use CCX directly.") #❗UNCOVERED: NEED TEST

    q_control = QuantumRegister(num_ctrl_qubits, name="ctrl")
    q_target = QuantumRegister(1, name="targ")
    q_ancilla = AncillaRegister(2, name="anc")
    qc = QuantumCircuit(q_control, q_target, q_ancilla, name="mcx_logn_depth")

    ladder_ops, final_ctrls = _build_logn_depth_ccx_ladder(
        num_ctrl_qubits, list(range(num_ctrl_qubits))
    )
    qc.compose(ladder_ops, q_control[:] + [q_ancilla[0]], inplace=True)
...
def synth_mcx_2_clean_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_mcx_2_dirty_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
...
def synth_c3x() -> QuantumCircuit:
...
def synth_c4x() -> QuantumCircuit:

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/qiskit/synthesis/__init__.py b/qiskit/synthesis/__init__.py
index a41bc042aa9b..ea33904fe816 100644
--- a/qiskit/synthesis/__init__.py
+++ b/qiskit/synthesis/__init__.py
@@ -127,6 +127,10 @@
 ==========================
 
 .. autofunction:: synth_mcmt_vchain
+.. autofunction:: synth_mcx_1_clean_kg24
+.. autofunction:: synth_mcx_1_dirty_kg24
+.. autofunction:: synth_mcx_2_clean_kg24
+.. autofunction:: synth_mcx_2_dirty_kg24
 .. autofunction:: synth_mcx_n_dirty_i15
 .. autofunction:: synth_mcx_n_clean_m15
 .. autofunction:: synth_mcx_1_clean_b95
@@ -220,6 +224,10 @@
 )
 from .multi_controlled import (
     synth_mcmt_vchain,
+    synth_mcx_1_clean_kg24,
+    synth_mcx_1_dirty_kg24,
+    synth_mcx_2_clean_kg24,
+    synth_mcx_2_dirty_kg24,
     synth_mcx_n_dirty_i15,
     synth_mcx_n_clean_m15,
     synth_mcx_1_clean_b95,
diff --git a/qiskit/synthesis/multi_controlled/__init__.py b/qiskit/synthesis/multi_controlled/__init__.py
index 0fa29553e7ed..bf1022ec8ff4 100644
--- a/qiskit/synthesis/multi_controlled/__init__.py
+++ b/qiskit/synthesis/multi_controlled/__init__.py
@@ -14,6 +14,10 @@
 
 from .mcmt_vchain import synth_mcmt_vchain
 from .mcx_synthesis import (
+    synth_mcx_1_clean_kg24,
+    synth_mcx_1_dirty_kg24,
+    synth_mcx_2_clean_kg24,
+    synth_mcx_2_dirty_kg24,
     synth_mcx_n_dirty_i15,
     synth_mcx_n_clean_m15,
     synth_mcx_1_clean_b95,
diff --git a/qiskit/synthesis/multi_controlled/mcx_synthesis.py b/qiskit/synthesis/multi_controlled/mcx_synthesis.py
index ddab35ed1173..baee3ad1d771 100644
--- a/qiskit/synthesis/multi_controlled/mcx_synthesis.py
+++ b/qiskit/synthesis/multi_controlled/mcx_synthesis.py
@@ -12,11 +12,12 @@
 
 """Module containing multi-controlled circuits synthesis with and without ancillary qubits."""
 
+from __future__ import annotations
 from math import ceil
 import numpy as np
 
-from qiskit.circuit import QuantumRegister
-from qiskit.circuit.quantumcircuit import QuantumCircuit
+from qiskit.exceptions import QiskitError
+from qiskit.circuit.quantumcircuit import QuantumCircuit, QuantumRegister, AncillaRegister
 from qiskit.circuit.library.standard_gates import (
     HGate,
     MCU1Gate,
@@ -300,6 +301,350 @@ def synth_mcx_noaux_v24(num_ctrl_qubits: int) -> QuantumCircuit:
     return qc
 
 
+def _linear_depth_ladder_ops(num_ladder_qubits: int) -> tuple[QuantumCircuit, list[int]]:
+    r"""
+    Helper function to create linear-depth ladder operations used in Khattar and Gidney's MCX synthesis.
+    In particular, this implements Step-1 and Step-2 on Fig. 3 of [1] except for the first and last
+    CCX gates.
+
+    Args:
+        num_ladder_qubits: No. of qubits involved in the ladder operation.
+
+    Returns:
+        A tuple consisting of the linear-depth ladder circuit and the index of control qubit to
+        apply the final CCX gate.
+
+    Raises:
+        QiskitError: If num_ladder_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    if num_ladder_qubits <= 2:
+        raise QiskitError("n_ctrls >= 3 to use MCX ladder. Otherwise, use CCX")
+
+    n = num_ladder_qubits + 1
+    qc = QuantumCircuit(n)
+    qreg = list(range(n))
+
+    # up-ladder
+    for i in range(2, n - 2, 2):
+        qc.ccx(qreg[i + 1], qreg[i + 2], qreg[i])
+        qc.x(qreg[i])
+
+    # down-ladder
+    if n % 2 != 0:
+        a, b, target = n - 3, n - 5, n - 6
+    else:
+        a, b, target = n - 1, n - 4, n - 5
+
+    if target > 0:
+        qc.ccx(qreg[a], qreg[b], qreg[target])
+        qc.x(qreg[target])
+
+    for i in range(target, 2, -2):
+        qc.ccx(qreg[i], qreg[i - 1], qreg[i - 2])
+        qc.x(qreg[i - 2])
+
+    mid_second_ctrl = 1 + max(0, 6 - n)
+    final_ctrl = qreg[mid_second_ctrl] - 1
+    return qc, final_ctrl
+
+
+def synth_mcx_1_kg24(num_ctrl_qubits: int, clean: bool = True) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`1` ancillary qubit as
+    described in Sec. 5 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+        clean: If True, the ancilla is clean, otherwise it is dirty.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    if num_ctrl_qubits <= 2:
+        raise QiskitError("kg24 synthesis requires at least 3 control qubits. Use CCX directly.")
+
+    q_controls = QuantumRegister(num_ctrl_qubits, name="ctrl")
+    q_target = QuantumRegister(1, name="targ")
+    q_ancilla = AncillaRegister(1, name="anc")
+    qc = QuantumCircuit(q_controls, q_target, q_ancilla, name="mcx_linear_depth")
+
+    ladder_ops, final_ctrl = _linear_depth_ladder_ops(num_ctrl_qubits)
+    qc.ccx(q_controls[0], q_controls[1], q_ancilla)  #                  # create cond. clean ancilla
+    qc.compose(ladder_ops, q_ancilla[:] + q_controls[:], inplace=True)  # up-ladder
+    qc.ccx(q_ancilla, q_controls[final_ctrl], q_target)  #              # target
+    qc.compose(  #                                                      # down-ladder
+        ladder_ops.inverse(),
+        q_ancilla[:] + q_controls[:],
+        inplace=True,
+    )
+    qc.ccx(q_controls[0], q_controls[1], q_ancilla)
+
+    if not clean:
+        # perform toggle-detection if ancilla is dirty
+        qc.compose(ladder_ops, q_ancilla[:] + q_controls[:], inplace=True)
+        qc.ccx(q_ancilla, q_controls[final_ctrl], q_target)
+        qc.compose(ladder_ops.inverse(), q_ancilla[:] + q_controls[:], inplace=True)
+
+    return qc
+
+
+def synth_mcx_1_clean_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`1` clean ancillary qubit
+    producing a circuit with :math:`2k-3` Toffoli gates and depth :math:`O(k)` as described in
+    Sec. 5.1 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    return synth_mcx_1_kg24(num_ctrl_qubits, clean=True)
+
+
+def synth_mcx_1_dirty_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`1` dirty ancillary qubit
+    producing a circuit with :math:`4k-8` Toffoli gates and depth :math:`O(k)` as described in
+    Sec. 5.3 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    return synth_mcx_1_kg24(num_ctrl_qubits, clean=False)
+
+
+def _n_parallel_ccx_x(n: int) -> QuantumCircuit:
+    r"""
+    Construct a quantum circuit for creating n-condionally clean ancillae using 3n qubits. This
+    implements Fig. 4a of [1]. The order of returned qubits is qr_a, qr_a, qr_target.
+
+    Args:
+        n: Number of conditionally clean ancillae to create.
+
+    Returns:
+        QuantumCircuit: The quantum circuit for creating n-condionally clean ancillae.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    n_qubits = 3 * n
+    q = QuantumRegister(n_qubits, name="q")
+    qc = QuantumCircuit(q, name=f"ccxn_{n}")
+    qr_a, qr_b, qr_target = q[:n], q[n : 2 * n], q[2 * n :]
+    qc.x(qr_target)
+    qc.ccx(qr_a, qr_b, qr_target)
+
+    return qc
+
+
+def _build_logn_depth_ccx_ladder(
+    ancilla_idx: int, ctrls: list[int], skip_cond_clean: bool = False
+) -> tuple[QuantumCircuit, list[int]]:
+    r"""
+    Helper function to build a log-depth ladder compose of CCX and X gates as shown in Fig. 4b of [1].
+
+    Args:
+        ancilla_idx: Index of the ancillary qubit.
+        ctrls: List of control qubits.
+        skip_cond_clean: If True, do not include the conditionally clean ancilla (step 1 and 5 in
+            Fig. 4b of [1]).
+
+    Returns:
+        A tuple consisting of the log-depth ladder circuit of conditionally clean ancillae and the
+        list of indices of control qubit to apply the linear-depth MCX gate.
+
+    Raises:
+        QiskitError: If no. of qubits in parallel CCX + X gates are not the same.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    qc = QuantumCircuit(len(ctrls) + 1)
+    anc = [ancilla_idx]
+    final_ctrls = []
+
+    while len(ctrls) > 1:
+        next_batch_len = min(len(anc) + 1, len(ctrls))
+        ctrls, nxt_batch = ctrls[next_batch_len:], ctrls[:next_batch_len]
+        new_anc = []
+        while len(nxt_batch) > 1:
+            ccx_n = len(nxt_batch) // 2
+            st = int(len(nxt_batch) % 2)
+            ccx_x, ccx_y, ccx_t = (
+                nxt_batch[st : st + ccx_n],
+                nxt_batch[st + ccx_n :],
+                anc[-ccx_n:],
+            )
+            if not len(ccx_x) == len(ccx_y) == ccx_n >= 1:
+                raise QiskitError(
+                    f"Invalid CCX gate parameters: {len(ccx_x)=} != {len(ccx_y)=} != {len(ccx_n)=}"
+                )
+            if ccx_t != [ancilla_idx]:
+                qc.compose(_n_parallel_ccx_x(ccx_n), ccx_x + ccx_y + ccx_t, inplace=True)
+            else:
+                if not skip_cond_clean:
+                    qc.ccx(ccx_x[0], ccx_y[0], ccx_t[0])  #  # create conditionally clean ancilla
+            new_anc += nxt_batch[st:]  #                     # newly created cond. clean ancilla
+            nxt_batch = ccx_t + nxt_batch[:st]
+            anc = anc[:-ccx_n]
+
+        anc = sorted(anc + new_anc)
+        final_ctrls += nxt_batch
+
+    final_ctrls += ctrls
+    final_ctrls = sorted(final_ctrls)
+    return qc, final_ctrls[:-1]  # exclude ancilla
+
+
+def synth_mcx_2_kg24(num_ctrl_qubits: int, clean: bool = True) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`2` ancillary qubits.
+    as described in Sec. 5 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+        clean: If True, the ancilla is clean, otherwise it is dirty.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    if num_ctrl_qubits <= 2:
+        raise QiskitError("kg24 synthesis requires at least 3 control qubits. Use CCX directly.")
+
+    q_control = QuantumRegister(num_ctrl_qubits, name="ctrl")
+    q_target = QuantumRegister(1, name="targ")
+    q_ancilla = AncillaRegister(2, name="anc")
+    qc = QuantumCircuit(q_control, q_target, q_ancilla, name="mcx_logn_depth")
+
+    ladder_ops, final_ctrls = _build_logn_depth_ccx_ladder(
+        num_ctrl_qubits, list(range(num_ctrl_qubits))
+    )
+    qc.compose(ladder_ops, q_control[:] + [q_ancilla[0]], inplace=True)
+    if len(final_ctrls) == 1:  # Already a toffoli
+        qc.ccx(q_ancilla[0], q_control[final_ctrls[0]], q_target)
+    else:
+        mid_mcx = synth_mcx_1_clean_kg24(len(final_ctrls) + 1)
+        qc.compose(
+            mid_mcx,
+            [q_ancilla[0]]
+            + q_control[final_ctrls]
+            + q_target[:]
+            + [q_ancilla[1]],  # ctrls, targ, anc
+            inplace=True,
+        )
+    qc.compose(ladder_ops.inverse(), q_control[:] + [q_ancilla[0]], inplace=True)
+
+    if not clean:
+        # perform toggle-detection if ancilla is dirty
+        ladder_ops_new, final_ctrls = _build_logn_depth_ccx_ladder(
+            num_ctrl_qubits, list(range(num_ctrl_qubits)), skip_cond_clean=True
+        )
+        qc.compose(ladder_ops_new, q_control[:] + [q_ancilla[0]], inplace=True)
+        if len(final_ctrls) == 1:
+            qc.ccx(q_ancilla[0], q_control[final_ctrls[0]], q_target)
+        else:
+            qc.compose(
+                mid_mcx,
+                [q_ancilla[0]] + q_control[final_ctrls] + q_target[:] + [q_ancilla[1]],
+                inplace=True,
+            )
+        qc.compose(ladder_ops_new.inverse(), q_control[:] + [q_ancilla[0]], inplace=True)
+
+    return qc
+
+
+def synth_mcx_2_clean_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`2` clean ancillary qubits
+    producing a circuit with :math:`2k-3` Toffoli gates and depth :math:`O(\log(k))` as described in
+    Sec. 5.2 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    return synth_mcx_2_kg24(num_ctrl_qubits, clean=True)
+
+
+def synth_mcx_2_dirty_kg24(num_ctrl_qubits: int) -> QuantumCircuit:
+    r"""
+    Synthesize a multi-controlled X gate with :math:`k` controls using :math:`2` dirty ancillary qubits
+    producing a circuit with :math:`4k-8` Toffoli gates and depth :math:`O(\log(k))` as described in
+    Sec. 5.4 of [1].
+
+    Args:
+        num_ctrl_qubits: The number of control qubits.
+
+    Returns:
+        The synthesized quantum circuit.
+
+    Raises:
+        QiskitError: If num_ctrl_qubits <= 2.
+
+    References:
+        1. Khattar and Gidney, Rise of conditionally clean ancillae for optimizing quantum circuits
+        `arXiv:2407.17966 <https://arxiv.org/abs/2407.17966>`__
+    """
+
+    return synth_mcx_2_kg24(num_ctrl_qubits, clean=False)
+
+
 def synth_c3x() -> QuantumCircuit:
     """Efficient synthesis of 3-controlled X-gate."""
 
diff --git a/releasenotes/notes/better_mcx_synthesis-7e6e265147bc1d33.yaml b/releasenotes/notes/better_mcx_synthesis-7e6e265147bc1d33.yaml
new file mode 100644
index 000000000000..9a79a706f750
--- /dev/null
+++ b/releasenotes/notes/better_mcx_synthesis-7e6e265147bc1d33.yaml
@@ -0,0 +1,21 @@
+---
+features_synthesis:
+  - |
+    Added new decompositions for :class:`.MCXGate` utilizing clean ancillae, improving circuit
+    depth and efficiency:
+    
+    * :func:`.synth_mcx_1_clean_kg24`, using 1 additional clean ancilla qubit
+    * :func:`.synth_mcx_1_dirty_kg24`, using 1 additional dirty ancilla qubit
+    * :func:`.synth_mcx_2_clean_kg24`, using 2 additional clean ancillary qubits
+    * :func:`.synth_mcx_2_dirty_kg24`, using 2 additional dirty ancillary qubits
+
+    Example usage:
+
+    .. code-block:: python
+        
+        from qiskit.synthesis.multi_controlled import synth_mcx_1_clean_kg24
+        
+        n_ctrls = 10
+        qc = synth_mcx_1_clean_kg24(n_ctrls)
+        qc.draw()
+
diff --git a/test/python/synthesis/test_multi_controlled_synthesis.py b/test/python/synthesis/test_multi_controlled_synthesis.py
index 45e3689a8388..2c85b3c5cd4f 100644
--- a/test/python/synthesis/test_multi_controlled_synthesis.py
+++ b/test/python/synthesis/test_multi_controlled_synthesis.py
@@ -43,6 +43,10 @@
     synth_mcx_n_dirty_i15,
     synth_mcx_n_clean_m15,
     synth_mcx_1_clean_b95,
+    synth_mcx_1_clean_kg24,
+    synth_mcx_1_dirty_kg24,
+    synth_mcx_2_clean_kg24,
+    synth_mcx_2_dirty_kg24,
     synth_mcx_gray_code,
     synth_mcx_noaux_v24,
     synth_c3x,
@@ -134,6 +138,42 @@ def test_mcx_1_clean_b95(self, num_ctrl_qubits: int):
             XGate(), num_ctrl_qubits, synthesized_circuit, clean_ancillas=True
         )
 
+    @data(3, 4, 5, 6, 7, 8)
+    def test_mcx_1_clean_kg24(self, num_ctrl_qubits: int):
+        """Test synth_mcx_1_clean_kg24 by comparing synthesized and expected matrices."""
+        # Note: the method requires at least 3 control qubits
+        synthesized_circuit = synth_mcx_1_clean_kg24(num_ctrl_qubits)
+        self.assertSynthesisCorrect(
+            XGate(), num_ctrl_qubits, synthesized_circuit, clean_ancillas=True
+        )
+
+    @data(3, 4, 5, 6, 7, 8)
+    def test_mcx_1_dirty_kg24(self, num_ctrl_qubits: int):
+        """Test synth_mcx_1_dirty_kg24 by comparing synthesized and expected matrices."""
+        # Note: the method requires at least 3 control qubits
+        synthesized_circuit = synth_mcx_1_dirty_kg24(num_ctrl_qubits)
+        self.assertSynthesisCorrect(
+            XGate(), num_ctrl_qubits, synthesized_circuit, clean_ancillas=False
+        )
+
+    @data(3, 4, 5, 6, 7, 8)
+    def test_mcx_2_clean_kg24(self, num_ctrl_qubits: int):
+        """Test synth_mcx_2_clean_kg24 by comparing synthesized and expected matrices."""
+        # Note: the method requires at least 3 control qubits
+        synthesized_circuit = synth_mcx_2_clean_kg24(num_ctrl_qubits)
+        self.assertSynthesisCorrect(
+            XGate(), num_ctrl_qubits, synthesized_circuit, clean_ancillas=True
+        )
+
+    @data(3, 4, 5, 6, 7, 8)
+    def test_mcx_2_dirty_kg24(self, num_ctrl_qubits: int):
+        """Test synth_mcx_2_dirty_kg24 by comparing synthesized and expected matrices."""
+        # Note: the method requires at least 3 control qubits
+        synthesized_circuit = synth_mcx_2_dirty_kg24(num_ctrl_qubits)
+        self.assertSynthesisCorrect(
+            XGate(), num_ctrl_qubits, synthesized_circuit, clean_ancillas=False
+        )
+
     @data(3, 4, 5, 6, 7, 8)
     def test_mcx_gray_code(self, num_ctrl_qubits: int):
         """Test synth_mcx_gray_code by comparing synthesized and expected matrices."""
@@ -232,6 +272,46 @@ def test_mcx_1_clean_b95_cx_count(self, num_ctrl_qubits: int):
         # The bound from the documentation of synth_mcx_1_clean_b95
         self.assertLessEqual(cx_count, 16 * num_ctrl_qubits - 8)
 
+    @data(3, 5, 10, 15)
+    def test_mcx_1_clean_kg24_cx_count(self, num_ctrl_qubits: int):
+        """Test synth_mcx_1_clean_kg24 bound on CX count."""
+        synthesized_circuit = synth_mcx_1_clean_kg24(num_ctrl_qubits)
+        transpiled_circuit = self.pm.run(synthesized_circuit)
+        cx_count = transpiled_circuit.count_ops()["cx"]
+        # Based on the bound from the Sec 5.1 of arXiv:2407.17966, assuming Toffoli decomposition
+        # requires 6 CX gates.
+        self.assertLessEqual(cx_count, 12 * num_ctrl_qubits - 18)
+
+    @data(3, 5, 10, 15)
+    def test_mcx_1_dirty_kg24_cx_count(self, num_ctrl_qubits: int):
+        """Test synth_mcx_1_dirty_kg24 bound on CX count."""
+        synthesized_circuit = synth_mcx_1_dirty_kg24(num_ctrl_qubits)
+        transpiled_circuit = self.pm.run(synthesized_circuit)
+        cx_count = transpiled_circuit.count_ops()["cx"]
+        ## Based on the bound from the Sec 5.3 of arXiv:2407.17966, assuming Toffoli decomposition
+        # requires 6 CX gates.
+        self.assertLessEqual(cx_count, 24 * num_ctrl_qubits - 48)
+
+    @data(3, 5, 10, 15)
+    def test_mcx_2_clean_kg24_cx_count(self, num_ctrl_qubits: int):
+        """Test synth_mcx_2_clean_kg24 bound on CX count."""
+        synthesized_circuit = synth_mcx_2_clean_kg24(num_ctrl_qubits)
+        transpiled_circuit = self.pm.run(synthesized_circuit)
+        cx_count = transpiled_circuit.count_ops()["cx"]
+        # Based on the bound from the Sec 5.2 of arXiv:2407.17966, assuming Toffoli decomposition
+        # requires 6 CX gates.
+        self.assertLessEqual(cx_count, 12 * num_ctrl_qubits - 18)
+
+    @data(3, 5, 10, 15)
+    def test_mcx_2_dirty_kg24_cx_count(self, num_ctrl_qubits: int):
+        """Test synth_mcx_2_dirty_kg24 bound on CX count."""
+        synthesized_circuit = synth_mcx_2_dirty_kg24(num_ctrl_qubits)
+        transpiled_circuit = self.pm.run(synthesized_circuit)
+        cx_count = transpiled_circuit.count_ops()["cx"]
+        # Based on the bound from the Sec 5.4 of arXiv:2407.17966, assuming Toffoli decomposition
+        # requires 6 CX gates.
+        self.assertLessEqual(cx_count, 24 * num_ctrl_qubits - 48)
+
     def test_c3x_cx_count(self):
         """Test synth_c3x bound on CX count."""
         synthesized_circuit = synth_c3x()

```
