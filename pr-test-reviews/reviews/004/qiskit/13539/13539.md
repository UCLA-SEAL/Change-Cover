## [PR 13539](https://github.com/Qiskit/qiskit/pull/13539)

## PR Summary

This pull request (PR #13539) enhances the `StabilizerState.expectation_value` method to accept `SparsePauliOp`, expanding its functionality within the Qiskit library. Key changes include updates to the method, the addition of a test to ensure its proper operation, and release notes documenting this enhancement. This update resolves issue #12422 and is part of the Quantum Info module related to states and operators. The test coverage increased slightly to 88.955%.

## Uncovered Lines

```python
--------------------------------------------------------------------------------
# qiskit/quantum_info/states/stabilizerstate.py
--------------------------------------------------------------------------------
class StabilizerState(QuantumState):
...
    def __init__(
        self,
        data: StabilizerState | Clifford | Pauli | QuantumCircuit | circuit.instruction.Instruction,
        validate: bool = True,
    ):
...
    def from_stabilizer_list(
        cls,
        stabilizers: Collection[str],
        allow_redundant: bool = False,
        allow_underconstrained: bool = False,
    ) -> StabilizerState:
...
    def __eq__(self, other):
...
    def __repr__(self):
...
    def clifford(self):
...
    def is_valid(self, atol=None, rtol=None):
...
    def _add(self, other):
...
    def _multiply(self, other):
...
    def trace(self) -> float:
...
    def purity(self) -> float:
...
    def to_operator(self) -> Operator:
...
    def conjugate(self):
...
    def tensor(self, other: StabilizerState) -> StabilizerState:
...
    def expand(self, other: StabilizerState) -> StabilizerState:
...
    def evolve(
        self, other: Clifford | QuantumCircuit | Instruction, qargs: list | None = None
    ) -> StabilizerState:
...
    def expectation_value(self, oper: Pauli | SparsePauliOp, qargs: None | list = None) -> complex:
...
        """
        if isinstance(oper, Pauli):
            return self._expectation_value_pauli(oper, qargs)

        if isinstance(oper, SparsePauliOp):
            return sum(
                coeff * self._expectation_value_pauli(Pauli((z, x)), qargs)
                for z, x, coeff in zip(oper.paulis.z, oper.paulis.x, oper.coeffs)
            )

        raise QiskitError( #❗UNCOVERED: NEED TEST
            "Operator for expectation value is not a Pauli or SparsePauliOp operator, " #❗UNCOVERED: NEED TEST
            f"but {type(oper)}." #❗UNCOVERED: NEED TEST
        ) #❗UNCOVERED: NEED TEST

    def _expectation_value_pauli(self, oper: Pauli, qargs: None | list = None) -> complex:
        """Compute the expectation value of a Pauli operator.

        Args:
            oper (Pauli): a Pauli operator to evaluate expval.
            qargs (None or list): subsystems to apply the operator on.

        Returns:
            complex: the expectation value (only 0 or 1 or -1 or i or -i).
...
    def equiv(self, other: StabilizerState) -> bool:
...
    def probabilities(self, qargs: None | list = None, decimals: None | int = None) -> np.ndarray:
...
    def probabilities_dict_from_bitstring(
        self,
        outcome_bitstring: str,
        qargs: None | list = None,
        decimals: None | int = None,
    ) -> dict[str, float]:
...
    def probabilities_dict(
        self, qargs: None | list = None, decimals: None | int = None
    ) -> dict[str, float]:
...
    def reset(self, qargs: list | None = None) -> StabilizerState:
...
    def measure(self, qargs: list | None = None) -> tuple:
...
    def sample_memory(self, shots: int, qargs: None | list = None) -> np.ndarray:
...
    def _measure_and_update(self, qubit, randbit):
...
    def _phase_exponent(x1, z1, x2, z2):
...
    def _rowsum(accum_pauli, accum_phase, row_pauli, row_phase):
...
    def _rowsum_nondeterministic(clifford, accum, row):
...
    def _rowsum_deterministic(clifford, aux_pauli, row):
...
    def _get_probabilities(
        self,
        qubits: range,
        outcome: list[str],
        outcome_prob: float,
        probs: dict[str, float],
        outcome_bitstring: str = None,
    ):
...
    def _get_probabilities_dict(
        self,
        outcome_bitstring: None | str = None,
        qargs: None | list = None,
        decimals: None | int = None,
    ) -> dict[str, float]:

--------------------------------------------------------------------------------
```

## PR Diff

```diff
diff --git a/qiskit/quantum_info/states/stabilizerstate.py b/qiskit/quantum_info/states/stabilizerstate.py
index b6bc8243b407..dfedb285fffa 100644
--- a/qiskit/quantum_info/states/stabilizerstate.py
+++ b/qiskit/quantum_info/states/stabilizerstate.py
@@ -24,7 +24,7 @@
 from qiskit.exceptions import QiskitError
 from qiskit.quantum_info.operators.op_shape import OpShape
 from qiskit.quantum_info.operators.operator import Operator
-from qiskit.quantum_info.operators.symplectic import Clifford, Pauli, PauliList
+from qiskit.quantum_info.operators.symplectic import Clifford, Pauli, PauliList, SparsePauliOp
 from qiskit.quantum_info.operators.symplectic.clifford_circuits import _append_x
 from qiskit.quantum_info.states.quantum_state import QuantumState
 from qiskit.circuit import QuantumCircuit, Instruction
@@ -259,7 +259,34 @@ def evolve(
         ret._data = self.clifford.compose(other.clifford, qargs=qargs)
         return ret
 
-    def expectation_value(self, oper: Pauli, qargs: None | list = None) -> complex:
+    def expectation_value(self, oper: Pauli | SparsePauliOp, qargs: None | list = None) -> complex:
+        """Compute the expectation value of a Pauli or SparsePauliOp operator.
+
+        Args:
+            oper: A Pauli or SparsePauliOp operator to evaluate the expectation value.
+            qargs: Subsystems to apply the operator on.
+
+        Returns:
+            The expectation value.
+
+        Raises:
+            QiskitError: if oper is not a Pauli or SparsePauliOp operator.
+        """
+        if isinstance(oper, Pauli):
+            return self._expectation_value_pauli(oper, qargs)
+
+        if isinstance(oper, SparsePauliOp):
+            return sum(
+                coeff * self._expectation_value_pauli(Pauli((z, x)), qargs)
+                for z, x, coeff in zip(oper.paulis.z, oper.paulis.x, oper.coeffs)
+            )
+
+        raise QiskitError(
+            "Operator for expectation value is not a Pauli or SparsePauliOp operator, "
+            f"but {type(oper)}."
+        )
+
+    def _expectation_value_pauli(self, oper: Pauli, qargs: None | list = None) -> complex:
         """Compute the expectation value of a Pauli operator.
 
         Args:
diff --git a/releasenotes/notes/stabilizerstate-expval-sparsepauliop-3e32a871d8e908ce.yaml b/releasenotes/notes/stabilizerstate-expval-sparsepauliop-3e32a871d8e908ce.yaml
new file mode 100644
index 000000000000..135156272dc4
--- /dev/null
+++ b/releasenotes/notes/stabilizerstate-expval-sparsepauliop-3e32a871d8e908ce.yaml
@@ -0,0 +1,5 @@
+---
+features_quantum_info:
+  - |
+    The method :meth:`.StabilizerState.expectation_value` can now accept an operator of type
+    :class:`.SparsePauliOp`.
diff --git a/test/python/quantum_info/states/test_stabilizerstate.py b/test/python/quantum_info/states/test_stabilizerstate.py
index 4e1659ff6999..f76df1134e8a 100644
--- a/test/python/quantum_info/states/test_stabilizerstate.py
+++ b/test/python/quantum_info/states/test_stabilizerstate.py
@@ -25,7 +25,7 @@
 from qiskit.quantum_info.random import random_clifford, random_pauli
 from qiskit.quantum_info.states import StabilizerState, Statevector
 from qiskit.circuit.library import IGate, XGate, HGate
-from qiskit.quantum_info.operators import Clifford, Pauli, Operator
+from qiskit.quantum_info.operators import Clifford, Pauli, Operator, SparsePauliOp
 from test import combine  # pylint: disable=wrong-import-order
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
 
@@ -1101,6 +1101,18 @@ def test_expval_random_subsystem(self, num_qubits):
             target = Statevector(qc).expectation_value(op, qargs)
             self.assertAlmostEqual(exp_val, target)
 
+    def test_expval_sparsepauliop(self):
+        """Test expectation_value method of SparsePauliOp"""
+        cliff = random_clifford(num_qubits=3, seed=1234)
+        stab = StabilizerState(cliff)
+        labels = ["XXX", "IXI", "YYY", "III"]
+        coeffs = [3.0, 5.5, -1j, 23]
+        spp_op = SparsePauliOp.from_list(list(zip(labels, coeffs)))
+        expval = stab.expectation_value(spp_op)
+        qc = cliff.to_circuit()
+        target = Statevector(qc).expectation_value(spp_op)
+        self.assertAlmostEqual(expval, target)
+
     def test_stabilizer_bell_equiv(self):
         """Test that two circuits produce the same stabilizer group."""
 

```
